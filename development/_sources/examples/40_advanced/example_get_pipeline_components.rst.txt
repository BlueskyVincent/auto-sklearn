
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/40_advanced/example_get_pipeline_components.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_40_advanced_example_get_pipeline_components.py>`
        to download the full example code or to run this example in your browser via Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_40_advanced_example_get_pipeline_components.py:


======================
Obtain run information
======================

The following example shows how to obtain information from a finished
Auto-sklearn run. In particular, it shows:
* how to query which models were evaluated by Auto-sklearn
* how to query the models in the final ensemble
* how to get general statistics on the what Auto-sklearn evaluated

Auto-sklearn is a wrapper on top of
the sklearn models. This example illustrates how to interact
with the sklearn components directly, in this case a PCA preprocessor.

.. GENERATED FROM PYTHON SOURCE LINES 17-25

.. code-block:: default

    from pprint import pprint

    import sklearn.datasets
    import sklearn.metrics

    import autosklearn.classification









.. GENERATED FROM PYTHON SOURCE LINES 26-28

Data Loading
============

.. GENERATED FROM PYTHON SOURCE LINES 28-34

.. code-block:: default


    X, y = sklearn.datasets.load_breast_cancer(return_X_y=True)
    X_train, X_test, y_train, y_test = sklearn.model_selection.train_test_split(
        X, y, random_state=1
    )








.. GENERATED FROM PYTHON SOURCE LINES 35-37

Build and fit the classifier
============================

.. GENERATED FROM PYTHON SOURCE LINES 37-48

.. code-block:: default


    automl = autosklearn.classification.AutoSklearnClassifier(
        time_left_for_this_task=30,
        per_run_time_limit=10,
        disable_evaluator_output=False,
        # To simplify querying the models in the final ensemble, we
        # restrict auto-sklearn to use only pca as a preprocessor
        include={"feature_preprocessor": ["pca"]},
    )
    automl.fit(X_train, y_train, dataset_name="breast_cancer")





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /home/runner/work/auto-sklearn/auto-sklearn/autosklearn/metalearning/metalearning/meta_base.py:76: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.
      self.metafeatures = self.metafeatures.append(metafeatures)
    /home/runner/work/auto-sklearn/auto-sklearn/autosklearn/metalearning/metalearning/meta_base.py:80: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.
      self.algorithm_runs[metric].append(runs)

    AutoSklearnClassifier(include={'feature_preprocessor': ['pca']},
                          per_run_time_limit=10, time_left_for_this_task=30)



.. GENERATED FROM PYTHON SOURCE LINES 49-51

Predict using the model
=======================

.. GENERATED FROM PYTHON SOURCE LINES 51-56

.. code-block:: default


    predictions = automl.predict(X_test)
    print("Accuracy score:{}".format(sklearn.metrics.accuracy_score(y_test, predictions)))






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Accuracy score:0.9440559440559441




.. GENERATED FROM PYTHON SOURCE LINES 57-73

Report the models found by Auto-Sklearn
=======================================

Auto-sklearn uses
`Ensemble Selection <https://www.cs.cornell.edu/~alexn/papers/shotgun.icml04.revised.rev2.pdf>`_
to construct ensembles in a post-hoc fashion. The ensemble is a linear
weighting of all models constructed during the hyperparameter optimization.
This prints the final ensemble. It is a dictionary where ``model_id`` of
each model is a key, and value is a dictionary containing information
of that model. A model's dict contains its ``'model_id'``, ``'rank'``,
``'cost'``, ``'ensemble_weight'``, and the model itself. The model is
given by the ``'data_preprocessor'``, ``'feature_preprocessor'``,
``'regressor'/'classifier'`` and ``'sklearn_regressor'/'sklearn_classifier'``
entries. But for the ``'cv'`` resampling strategy, the same for each cv
model is stored in the ``'estimators'`` list in the dict, along with the
``'voting_model'``.

.. GENERATED FROM PYTHON SOURCE LINES 73-76

.. code-block:: default


    pprint(automl.show_models(), indent=4)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /home/runner/work/auto-sklearn/auto-sklearn/autosklearn/automl.py:2127: UserWarning: No models in the ensemble. Kindly provide an ensemble class.
      warnings.warn(
    {}




.. GENERATED FROM PYTHON SOURCE LINES 77-82

Report statistics about the search
==================================

Print statistics about the auto-sklearn run such as number of
iterations, number of models failed with a time out etc.

.. GENERATED FROM PYTHON SOURCE LINES 82-84

.. code-block:: default

    print(automl.sprint_statistics())





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    auto-sklearn results:
      Dataset name: breast_cancer
      Metric: accuracy
      Best validation score: 0.971631
      Number of target algorithm runs: 11
      Number of successful target algorithm runs: 10
      Number of crashed target algorithm runs: 0
      Number of target algorithms that exceeded the time limit: 1
      Number of target algorithms that exceeded the memory limit: 0





.. GENERATED FROM PYTHON SOURCE LINES 85-92

Detailed statistics about the search - part 1
=============================================

Auto-sklearn also keeps detailed statistics of the hyperparameter
optimization procedurce, which are stored in a so-called
`run history <https://automl.github.io/SMAC3/master/apidoc/smac.
runhistory.runhistory.html#smac.runhistory.runhistory.RunHistory>`_.

.. GENERATED FROM PYTHON SOURCE LINES 92-95

.. code-block:: default


    print(automl.automl_.runhistory_)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    <smac.runhistory.runhistory.RunHistory object at 0x7ff23b0a4640>




.. GENERATED FROM PYTHON SOURCE LINES 96-97

Runs are stored inside an ``OrderedDict`` called ``data``:

.. GENERATED FROM PYTHON SOURCE LINES 97-100

.. code-block:: default


    print(len(automl.automl_.runhistory_.data))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    12




.. GENERATED FROM PYTHON SOURCE LINES 101-102

Let's iterative over all entries

.. GENERATED FROM PYTHON SOURCE LINES 102-108

.. code-block:: default


    for run_key in automl.automl_.runhistory_.data:
        print("#########")
        print(run_key)
        print(automl.automl_.runhistory_.data[run_key])





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    #########
    RunKey(config_id=1, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.07801418439716312, time=1.617546558380127, status=<StatusType.SUCCESS: 1>, starttime=1653920240.567317, endtime=1653920242.2043989, additional_info={'duration': 1.5224416255950928, 'num_run': 2, 'train_loss': 0.0, 'configuration_origin': 'Initial design'})
    #########
    RunKey(config_id=2, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.07092198581560283, time=1.4339935779571533, status=<StatusType.SUCCESS: 1>, starttime=1653920242.2613997, endtime=1653920243.7186902, additional_info={'duration': 1.344569444656372, 'num_run': 3, 'train_loss': 0.06315789473684208, 'configuration_origin': 'Initial design'})
    #########
    RunKey(config_id=3, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.028368794326241176, time=1.2381927967071533, status=<StatusType.SUCCESS: 1>, starttime=1653920243.8134096, endtime=1653920245.074292, additional_info={'duration': 1.167677402496338, 'num_run': 4, 'train_loss': 0.04210526315789476, 'configuration_origin': 'Initial design'})
    #########
    RunKey(config_id=4, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.1063829787234043, time=0.7783868312835693, status=<StatusType.SUCCESS: 1>, starttime=1653920245.1826115, endtime=1653920245.9826274, additional_info={'duration': 0.713292121887207, 'num_run': 5, 'train_loss': 0.0, 'configuration_origin': 'Initial design'})
    #########
    RunKey(config_id=5, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.11347517730496459, time=0.640221357345581, status=<StatusType.SUCCESS: 1>, starttime=1653920246.1033309, endtime=1653920246.7651803, additional_info={'duration': 0.574209451675415, 'num_run': 6, 'train_loss': 0.09122807017543855, 'configuration_origin': 'Initial design'})
    #########
    RunKey(config_id=6, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.03546099290780147, time=0.8412725925445557, status=<StatusType.SUCCESS: 1>, starttime=1653920249.248146, endtime=1653920250.110747, additional_info={'duration': 0.7698974609375, 'num_run': 7, 'train_loss': 0.007017543859649145, 'configuration_origin': 'Random Search (sorted)'})
    #########
    RunKey(config_id=7, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.04255319148936165, time=0.8680245876312256, status=<StatusType.SUCCESS: 1>, starttime=1653920250.2734387, endtime=1653920251.163147, additional_info={'duration': 0.8010878562927246, 'num_run': 8, 'train_loss': 0.06666666666666665, 'configuration_origin': 'Random Search'})
    #########
    RunKey(config_id=8, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.05673758865248224, time=0.6584157943725586, status=<StatusType.SUCCESS: 1>, starttime=1653920251.3400202, endtime=1653920252.0194848, additional_info={'duration': 0.593040943145752, 'num_run': 9, 'train_loss': 0.06315789473684208, 'configuration_origin': 'Random Search'})
    #########
    RunKey(config_id=9, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.03546099290780147, time=1.3313453197479248, status=<StatusType.SUCCESS: 1>, starttime=1653920254.9399705, endtime=1653920256.2956367, additional_info={'duration': 1.2546353340148926, 'num_run': 10, 'train_loss': 0.0, 'configuration_origin': 'Random Search (sorted)'})
    #########
    RunKey(config_id=10, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.03546099290780147, time=0.9268374443054199, status=<StatusType.SUCCESS: 1>, starttime=1653920256.5085847, endtime=1653920257.4588032, additional_info={'duration': 0.8632063865661621, 'num_run': 11, 'train_loss': 0.01403508771929829, 'configuration_origin': 'Random Search'})
    #########
    RunKey(config_id=11, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=1.0, time=1.0070185661315918, status=<StatusType.TIMEOUT: 2>, starttime=1653920257.6855106, endtime=1653920259.7139206, additional_info={'error': 'Timeout', 'configuration_origin': 'Random Search'})
    #########
    RunKey(config_id=12, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=1.0, time=0.0, status=<StatusType.STOP: 8>, starttime=1653920259.7840765, endtime=1653920259.7840767, additional_info={})




.. GENERATED FROM PYTHON SOURCE LINES 109-110

and have a detailed look at one entry:

.. GENERATED FROM PYTHON SOURCE LINES 110-114

.. code-block:: default


    run_key = list(automl.automl_.runhistory_.data.keys())[0]
    run_value = automl.automl_.runhistory_.data[run_key]








.. GENERATED FROM PYTHON SOURCE LINES 115-116

The ``run_key`` contains all information describing a run:

.. GENERATED FROM PYTHON SOURCE LINES 116-122

.. code-block:: default


    print("Configuration ID:", run_key.config_id)
    print("Instance:", run_key.instance_id)
    print("Seed:", run_key.seed)
    print("Budget:", run_key.budget)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Configuration ID: 1
    Instance: {"task_id": "breast_cancer"}
    Seed: 0
    Budget: 0.0




.. GENERATED FROM PYTHON SOURCE LINES 123-124

and the configuration can be looked up in the run history as well:

.. GENERATED FROM PYTHON SOURCE LINES 124-127

.. code-block:: default


    print(automl.automl_.runhistory_.ids_config[run_key.config_id])





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Configuration(values={
      'balancing:strategy': 'none',
      'classifier:__choice__': 'random_forest',
      'classifier:random_forest:bootstrap': 'True',
      'classifier:random_forest:criterion': 'gini',
      'classifier:random_forest:max_depth': 'None',
      'classifier:random_forest:max_features': 0.5,
      'classifier:random_forest:max_leaf_nodes': 'None',
      'classifier:random_forest:min_impurity_decrease': 0.0,
      'classifier:random_forest:min_samples_leaf': 1,
      'classifier:random_forest:min_samples_split': 2,
      'classifier:random_forest:min_weight_fraction_leaf': 0.0,
      'data_preprocessor:__choice__': 'feature_type',
      'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding',
      'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer',
      'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.01,
      'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'mean',
      'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'standardize',
      'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
      'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 0,
      'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
      'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
      'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
      'feature_preprocessor:__choice__': 'pca',
      'feature_preprocessor:pca:keep_variance': 0.9999,
      'feature_preprocessor:pca:whiten': 'False',
    })





.. GENERATED FROM PYTHON SOURCE LINES 128-134

The only other important entry is the budget in case you are using
auto-sklearn with
:ref:`sphx_glr_examples_60_search_example_successive_halving.py`.
The remaining parts of the key can be ignored for auto-sklearn and are
only there because the underlying optimizer, SMAC, can handle more general
problems, too.

.. GENERATED FROM PYTHON SOURCE LINES 136-137

The ``run_value`` contains all output from running the configuration:

.. GENERATED FROM PYTHON SOURCE LINES 137-145

.. code-block:: default


    print("Cost:", run_value.cost)
    print("Time:", run_value.time)
    print("Status:", run_value.status)
    print("Additional information:", run_value.additional_info)
    print("Start time:", run_value.starttime)
    print("End time", run_value.endtime)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Cost: 0.07801418439716312
    Time: 1.617546558380127
    Status: StatusType.SUCCESS
    Additional information: {'duration': 1.5224416255950928, 'num_run': 2, 'train_loss': 0.0, 'configuration_origin': 'Initial design'}
    Start time: 1653920240.567317
    End time 1653920242.2043989




.. GENERATED FROM PYTHON SOURCE LINES 146-152

Cost is basically the same as a loss. In case the metric to optimize for
should be maximized, it is internally transformed into a minimization
metric. Additionally, the status type gives information on whether the run
was successful, while the additional information's most interesting entry
is the internal training loss. Furthermore, there is detailed information
on the runtime available.

.. GENERATED FROM PYTHON SOURCE LINES 154-157

As an example, let's find the best configuration evaluated. As
Auto-sklearn solves a minimization problem internally, we need to look
for the entry with the lowest loss:

.. GENERATED FROM PYTHON SOURCE LINES 157-169

.. code-block:: default


    losses_and_configurations = [
        (run_value.cost, run_key.config_id)
        for run_key, run_value in automl.automl_.runhistory_.data.items()
    ]
    losses_and_configurations.sort()
    print("Lowest loss:", losses_and_configurations[0][0])
    print(
        "Best configuration:",
        automl.automl_.runhistory_.ids_config[losses_and_configurations[0][1]],
    )





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Lowest loss: 0.028368794326241176
    Best configuration: Configuration(values={
      'balancing:strategy': 'weighting',
      'classifier:__choice__': 'mlp',
      'classifier:mlp:activation': 'tanh',
      'classifier:mlp:alpha': 1.103855734598575e-05,
      'classifier:mlp:batch_size': 'auto',
      'classifier:mlp:beta_1': 0.9,
      'classifier:mlp:beta_2': 0.999,
      'classifier:mlp:early_stopping': 'valid',
      'classifier:mlp:epsilon': 1e-08,
      'classifier:mlp:hidden_layer_depth': 3,
      'classifier:mlp:learning_rate_init': 0.00014375616988222174,
      'classifier:mlp:n_iter_no_change': 32,
      'classifier:mlp:num_nodes_per_layer': 229,
      'classifier:mlp:shuffle': 'True',
      'classifier:mlp:solver': 'adam',
      'classifier:mlp:tol': 0.0001,
      'classifier:mlp:validation_fraction': 0.1,
      'data_preprocessor:__choice__': 'feature_type',
      'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding',
      'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer',
      'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.002766772136115771,
      'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'most_frequent',
      'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'quantile_transformer',
      'data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:n_quantiles': 180,
      'data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:output_distribution': 'uniform',
      'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
      'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
      'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
      'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
      'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
      'feature_preprocessor:__choice__': 'pca',
      'feature_preprocessor:pca:keep_variance': 0.7895711479212801,
      'feature_preprocessor:pca:whiten': 'True',
    })





.. GENERATED FROM PYTHON SOURCE LINES 170-177

Detailed statistics about the search - part 2
=============================================

To maintain compatibility with scikit-learn, Auto-sklearn gives the
same data as
`cv_results_ <https://scikit-learn.org/stable/modules/generated/sklearn.
model_selection.GridSearchCV.html>`_.

.. GENERATED FROM PYTHON SOURCE LINES 177-180

.. code-block:: default


    print(automl.cv_results_)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    {'mean_test_score': array([0.92198582, 0.92907801, 0.97163121, 0.89361702, 0.88652482,
           0.96453901, 0.95744681, 0.94326241, 0.96453901, 0.96453901,
           0.        ]), 'rank_test_scores': array([ 8,  7,  1,  9, 10,  2,  5,  6,  2,  2, 11]), 'mean_fit_time': array([1.61754656, 1.43399358, 1.2381928 , 0.77838683, 0.64022136,
           0.84127259, 0.86802459, 0.65841579, 1.33134532, 0.92683744,
           1.00701857]), 'params': [{'balancing:strategy': 'none', 'classifier:__choice__': 'random_forest', 'data_preprocessor:__choice__': 'feature_type', 'feature_preprocessor:__choice__': 'pca', 'classifier:random_forest:bootstrap': 'True', 'classifier:random_forest:criterion': 'gini', 'classifier:random_forest:max_depth': 'None', 'classifier:random_forest:max_features': 0.5, 'classifier:random_forest:max_leaf_nodes': 'None', 'classifier:random_forest:min_impurity_decrease': 0.0, 'classifier:random_forest:min_samples_leaf': 1, 'classifier:random_forest:min_samples_split': 2, 'classifier:random_forest:min_weight_fraction_leaf': 0.0, 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'standardize', 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding', 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100, 'feature_preprocessor:pca:keep_variance': 0.9999, 'feature_preprocessor:pca:whiten': 'False', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.01, 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute', 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1, 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 0}, {'balancing:strategy': 'none', 'classifier:__choice__': 'random_forest', 'data_preprocessor:__choice__': 'feature_type', 'feature_preprocessor:__choice__': 'pca', 'classifier:random_forest:bootstrap': 'True', 'classifier:random_forest:criterion': 'gini', 'classifier:random_forest:max_depth': 'None', 'classifier:random_forest:max_features': 0.9331254454871041, 'classifier:random_forest:max_leaf_nodes': 'None', 'classifier:random_forest:min_impurity_decrease': 0.0, 'classifier:random_forest:min_samples_leaf': 2, 'classifier:random_forest:min_samples_split': 20, 'classifier:random_forest:min_weight_fraction_leaf': 0.0, 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'none', 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding', 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100, 'feature_preprocessor:pca:keep_variance': 0.9967857433838874, 'feature_preprocessor:pca:whiten': 'False', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.005069923784737444, 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute', 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1, 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1}, {'balancing:strategy': 'weighting', 'classifier:__choice__': 'mlp', 'data_preprocessor:__choice__': 'feature_type', 'feature_preprocessor:__choice__': 'pca', 'classifier:mlp:activation': 'tanh', 'classifier:mlp:alpha': 1.103855734598575e-05, 'classifier:mlp:batch_size': 'auto', 'classifier:mlp:beta_1': 0.9, 'classifier:mlp:beta_2': 0.999, 'classifier:mlp:early_stopping': 'valid', 'classifier:mlp:epsilon': 1e-08, 'classifier:mlp:hidden_layer_depth': 3, 'classifier:mlp:learning_rate_init': 0.00014375616988222174, 'classifier:mlp:n_iter_no_change': 32, 'classifier:mlp:num_nodes_per_layer': 229, 'classifier:mlp:shuffle': 'True', 'classifier:mlp:solver': 'adam', 'classifier:mlp:tol': 0.0001, 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'most_frequent', 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'quantile_transformer', 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding', 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100, 'feature_preprocessor:pca:keep_variance': 0.7895711479212801, 'feature_preprocessor:pca:whiten': 'True', 'classifier:mlp:validation_fraction': 0.1, 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.002766772136115771, 'data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:n_quantiles': 180, 'data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:output_distribution': 'uniform', 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute', 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1, 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1}, {'balancing:strategy': 'weighting', 'classifier:__choice__': 'k_nearest_neighbors', 'data_preprocessor:__choice__': 'feature_type', 'feature_preprocessor:__choice__': 'pca', 'classifier:k_nearest_neighbors:n_neighbors': 4, 'classifier:k_nearest_neighbors:p': 2, 'classifier:k_nearest_neighbors:weights': 'distance', 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'normalize', 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding', 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100, 'feature_preprocessor:pca:keep_variance': 0.8047274080856589, 'feature_preprocessor:pca:whiten': 'False', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.008015420020402715, 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute', 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1, 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1}, {'balancing:strategy': 'none', 'classifier:__choice__': 'libsvm_svc', 'data_preprocessor:__choice__': 'feature_type', 'feature_preprocessor:__choice__': 'pca', 'classifier:libsvm_svc:C': 100.5905006626969, 'classifier:libsvm_svc:gamma': 0.011333066835975528, 'classifier:libsvm_svc:kernel': 'poly', 'classifier:libsvm_svc:max_iter': -1, 'classifier:libsvm_svc:shrinking': 'True', 'classifier:libsvm_svc:tol': 0.012391313886912093, 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'minmax', 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding', 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100, 'feature_preprocessor:pca:keep_variance': 0.9290439925152777, 'feature_preprocessor:pca:whiten': 'False', 'classifier:libsvm_svc:coef0': 0.08087614244138486, 'classifier:libsvm_svc:degree': 3, 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.010000000000000004, 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute', 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1, 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1}, {'balancing:strategy': 'weighting', 'classifier:__choice__': 'liblinear_svc', 'data_preprocessor:__choice__': 'feature_type', 'feature_preprocessor:__choice__': 'pca', 'classifier:liblinear_svc:C': 10.369811497206404, 'classifier:liblinear_svc:dual': 'False', 'classifier:liblinear_svc:fit_intercept': 'True', 'classifier:liblinear_svc:intercept_scaling': 1, 'classifier:liblinear_svc:loss': 'squared_hinge', 'classifier:liblinear_svc:multi_class': 'ovr', 'classifier:liblinear_svc:penalty': 'l2', 'classifier:liblinear_svc:tol': 0.0015130257264171173, 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'no_coalescense', 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'power_transformer', 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding_distinct', 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 137, 'feature_preprocessor:pca:keep_variance': 0.9677965620214456, 'feature_preprocessor:pca:whiten': 'False', 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:min_df_choice': 'min_df_relative', 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:ngram_upper_bound': 1, 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:min_df_relative': 0.08656832316003299}, {'balancing:strategy': 'weighting', 'classifier:__choice__': 'lda', 'data_preprocessor:__choice__': 'feature_type', 'feature_preprocessor:__choice__': 'pca', 'classifier:lda:shrinkage': 'None', 'classifier:lda:tol': 0.010552900863349885, 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'most_frequent', 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'quantile_transformer', 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding', 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 2, 'feature_preprocessor:pca:keep_variance': 0.5940439727806581, 'feature_preprocessor:pca:whiten': 'True', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.000603245839093932, 'data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:n_quantiles': 1660, 'data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:output_distribution': 'normal', 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_relative', 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1, 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_relative': 0.36019594124973353}, {'balancing:strategy': 'none', 'classifier:__choice__': 'decision_tree', 'data_preprocessor:__choice__': 'feature_type', 'feature_preprocessor:__choice__': 'pca', 'classifier:decision_tree:criterion': 'gini', 'classifier:decision_tree:max_depth_factor': 0.09679641236056158, 'classifier:decision_tree:max_features': 1.0, 'classifier:decision_tree:max_leaf_nodes': 'None', 'classifier:decision_tree:min_impurity_decrease': 0.0, 'classifier:decision_tree:min_samples_leaf': 12, 'classifier:decision_tree:min_samples_split': 10, 'classifier:decision_tree:min_weight_fraction_leaf': 0.0, 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'encoding', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'median', 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'quantile_transformer', 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'tfidf_encoding', 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 15, 'feature_preprocessor:pca:keep_variance': 0.9889862560610739, 'feature_preprocessor:pca:whiten': 'False', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.016731911468974733, 'data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:n_quantiles': 373, 'data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:output_distribution': 'uniform', 'data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:min_df_choice': 'min_df_relative', 'data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:ngram_upper_bound': 2, 'data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:use_idf': False, 'data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:min_df_relative': 0.0969631806397533}, {'balancing:strategy': 'weighting', 'classifier:__choice__': 'adaboost', 'data_preprocessor:__choice__': 'feature_type', 'feature_preprocessor:__choice__': 'pca', 'classifier:adaboost:algorithm': 'SAMME.R', 'classifier:adaboost:learning_rate': 0.3263027997499721, 'classifier:adaboost:max_depth': 1, 'classifier:adaboost:n_estimators': 219, 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'no_coalescense', 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'median', 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'minmax', 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'tfidf_encoding', 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 44, 'feature_preprocessor:pca:keep_variance': 0.8981112252440566, 'feature_preprocessor:pca:whiten': 'True', 'data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:min_df_choice': 'min_df_absolute', 'data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:ngram_upper_bound': 2, 'data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:use_idf': True, 'data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:min_df_absolute': 6}, {'balancing:strategy': 'weighting', 'classifier:__choice__': 'passive_aggressive', 'data_preprocessor:__choice__': 'feature_type', 'feature_preprocessor:__choice__': 'pca', 'classifier:passive_aggressive:C': 0.009945692083946422, 'classifier:passive_aggressive:average': 'False', 'classifier:passive_aggressive:fit_intercept': 'True', 'classifier:passive_aggressive:loss': 'hinge', 'classifier:passive_aggressive:tol': 0.00039533312192938314, 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'no_coalescense', 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'most_frequent', 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'standardize', 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding', 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 1174, 'feature_preprocessor:pca:keep_variance': 0.9742266416789866, 'feature_preprocessor:pca:whiten': 'False', 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute', 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 3, 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 9}, {'balancing:strategy': 'weighting', 'classifier:__choice__': 'mlp', 'data_preprocessor:__choice__': 'feature_type', 'feature_preprocessor:__choice__': 'pca', 'classifier:mlp:activation': 'relu', 'classifier:mlp:alpha': 2.0254725986516976e-07, 'classifier:mlp:batch_size': 'auto', 'classifier:mlp:beta_1': 0.9, 'classifier:mlp:beta_2': 0.999, 'classifier:mlp:early_stopping': 'train', 'classifier:mlp:epsilon': 1e-08, 'classifier:mlp:hidden_layer_depth': 1, 'classifier:mlp:learning_rate_init': 0.007525773377111986, 'classifier:mlp:n_iter_no_change': 32, 'classifier:mlp:num_nodes_per_layer': 224, 'classifier:mlp:shuffle': 'True', 'classifier:mlp:solver': 'adam', 'classifier:mlp:tol': 0.0001, 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'no_coalescense', 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'most_frequent', 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'standardize', 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'tfidf_encoding', 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 5796, 'feature_preprocessor:pca:keep_variance': 0.8322479037809868, 'feature_preprocessor:pca:whiten': 'False', 'data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:min_df_choice': 'min_df_absolute', 'data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:ngram_upper_bound': 3, 'data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:use_idf': False, 'data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:min_df_absolute': 2}], 'status': ['Success', 'Success', 'Success', 'Success', 'Success', 'Success', 'Success', 'Success', 'Success', 'Success', 'Timeout'], 'budgets': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 'param_balancing:strategy': masked_array(data=['none', 'none', 'weighting', 'weighting', 'none',
                       'weighting', 'weighting', 'none', 'weighting',
                       'weighting', 'weighting'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False],
           fill_value='N/A',
                dtype='<U9'), 'param_classifier:__choice__': masked_array(data=['random_forest', 'random_forest', 'mlp',
                       'k_nearest_neighbors', 'libsvm_svc', 'liblinear_svc',
                       'lda', 'decision_tree', 'adaboost',
                       'passive_aggressive', 'mlp'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False],
           fill_value='N/A',
                dtype='<U19'), 'param_data_preprocessor:__choice__': masked_array(data=['feature_type', 'feature_type', 'feature_type',
                       'feature_type', 'feature_type', 'feature_type',
                       'feature_type', 'feature_type', 'feature_type',
                       'feature_type', 'feature_type'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False],
           fill_value='N/A',
                dtype='<U12'), 'param_feature_preprocessor:__choice__': masked_array(data=['pca', 'pca', 'pca', 'pca', 'pca', 'pca', 'pca', 'pca',
                       'pca', 'pca', 'pca'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False],
           fill_value='N/A',
                dtype='<U3'), 'param_classifier:adaboost:algorithm': masked_array(data=[--, --, --, --, --, --, --, --, 'SAMME.R', --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                       False,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:adaboost:learning_rate': masked_array(data=[--, --, --, --, --, --, --, --, 0.3263027997499721, --,
                       --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                       False,  True,  True],
           fill_value=1e+20), 'param_classifier:adaboost:max_depth': masked_array(data=[--, --, --, --, --, --, --, --, 1.0, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                       False,  True,  True],
           fill_value=1e+20), 'param_classifier:adaboost:n_estimators': masked_array(data=[--, --, --, --, --, --, --, --, 219.0, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                       False,  True,  True],
           fill_value=1e+20), 'param_classifier:bernoulli_nb:alpha': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:bernoulli_nb:fit_prior': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:decision_tree:criterion': masked_array(data=[--, --, --, --, --, --, --, 'gini', --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False,
                        True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:decision_tree:max_depth_factor': masked_array(data=[--, --, --, --, --, --, --, 0.09679641236056158, --,
                       --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False,
                        True,  True,  True],
           fill_value=1e+20), 'param_classifier:decision_tree:max_features': masked_array(data=[--, --, --, --, --, --, --, 1.0, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False,
                        True,  True,  True],
           fill_value=1e+20), 'param_classifier:decision_tree:max_leaf_nodes': masked_array(data=[--, --, --, --, --, --, --, 'None', --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False,
                        True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:decision_tree:min_impurity_decrease': masked_array(data=[--, --, --, --, --, --, --, 0.0, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False,
                        True,  True,  True],
           fill_value=1e+20), 'param_classifier:decision_tree:min_samples_leaf': masked_array(data=[--, --, --, --, --, --, --, 12.0, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False,
                        True,  True,  True],
           fill_value=1e+20), 'param_classifier:decision_tree:min_samples_split': masked_array(data=[--, --, --, --, --, --, --, 10.0, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False,
                        True,  True,  True],
           fill_value=1e+20), 'param_classifier:decision_tree:min_weight_fraction_leaf': masked_array(data=[--, --, --, --, --, --, --, 0.0, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False,
                        True,  True,  True],
           fill_value=1e+20), 'param_classifier:extra_trees:bootstrap': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:extra_trees:criterion': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:extra_trees:max_depth': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:extra_trees:max_features': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:extra_trees:max_leaf_nodes': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:extra_trees:min_impurity_decrease': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:extra_trees:min_samples_leaf': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:extra_trees:min_samples_split': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:extra_trees:min_weight_fraction_leaf': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:gradient_boosting:early_stop': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:gradient_boosting:l2_regularization': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:gradient_boosting:learning_rate': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:gradient_boosting:loss': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:gradient_boosting:max_bins': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:gradient_boosting:max_depth': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:gradient_boosting:max_leaf_nodes': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:gradient_boosting:min_samples_leaf': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:gradient_boosting:scoring': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:gradient_boosting:tol': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:k_nearest_neighbors:n_neighbors': masked_array(data=[--, --, --, 4.0, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True, False,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20), 'param_classifier:k_nearest_neighbors:p': masked_array(data=[--, --, --, 2.0, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True, False,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20), 'param_classifier:k_nearest_neighbors:weights': masked_array(data=[--, --, --, 'distance', --, --, --, --, --, --, --],
                 mask=[ True,  True,  True, False,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:lda:shrinkage': masked_array(data=[--, --, --, --, --, --, 'None', --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True, False,  True,
                        True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:lda:tol': masked_array(data=[--, --, --, --, --, --, 0.010552900863349885, --, --,
                       --, --],
                 mask=[ True,  True,  True,  True,  True,  True, False,  True,
                        True,  True,  True],
           fill_value=1e+20), 'param_classifier:liblinear_svc:C': masked_array(data=[--, --, --, --, --, 10.369811497206404, --, --, --, --,
                       --],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True],
           fill_value=1e+20), 'param_classifier:liblinear_svc:dual': masked_array(data=[--, --, --, --, --, 'False', --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:liblinear_svc:fit_intercept': masked_array(data=[--, --, --, --, --, 'True', --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:liblinear_svc:intercept_scaling': masked_array(data=[--, --, --, --, --, 1.0, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True],
           fill_value=1e+20), 'param_classifier:liblinear_svc:loss': masked_array(data=[--, --, --, --, --, 'squared_hinge', --, --, --, --,
                       --],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:liblinear_svc:multi_class': masked_array(data=[--, --, --, --, --, 'ovr', --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:liblinear_svc:penalty': masked_array(data=[--, --, --, --, --, 'l2', --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:liblinear_svc:tol': masked_array(data=[--, --, --, --, --, 0.0015130257264171173, --, --, --,
                       --, --],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True],
           fill_value=1e+20), 'param_classifier:libsvm_svc:C': masked_array(data=[--, --, --, --, 100.5905006626969, --, --, --, --, --,
                       --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20), 'param_classifier:libsvm_svc:gamma': masked_array(data=[--, --, --, --, 0.011333066835975528, --, --, --, --,
                       --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20), 'param_classifier:libsvm_svc:kernel': masked_array(data=[--, --, --, --, 'poly', --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True,
                        True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:libsvm_svc:max_iter': masked_array(data=[--, --, --, --, -1.0, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20), 'param_classifier:libsvm_svc:shrinking': masked_array(data=[--, --, --, --, 'True', --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True,
                        True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:libsvm_svc:tol': masked_array(data=[--, --, --, --, 0.012391313886912093, --, --, --, --,
                       --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20), 'param_classifier:mlp:activation': masked_array(data=[--, --, 'tanh', --, --, --, --, --, --, --, 'relu'],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True,
                        True,  True, False],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:mlp:alpha': masked_array(data=[--, --, 1.103855734598575e-05, --, --, --, --, --, --,
                       --, 2.0254725986516976e-07],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True,
                        True,  True, False],
           fill_value=1e+20), 'param_classifier:mlp:batch_size': masked_array(data=[--, --, 'auto', --, --, --, --, --, --, --, 'auto'],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True,
                        True,  True, False],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:mlp:beta_1': masked_array(data=[--, --, 0.9, --, --, --, --, --, --, --, 0.9],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True,
                        True,  True, False],
           fill_value=1e+20), 'param_classifier:mlp:beta_2': masked_array(data=[--, --, 0.999, --, --, --, --, --, --, --, 0.999],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True,
                        True,  True, False],
           fill_value=1e+20), 'param_classifier:mlp:early_stopping': masked_array(data=[--, --, 'valid', --, --, --, --, --, --, --, 'train'],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True,
                        True,  True, False],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:mlp:epsilon': masked_array(data=[--, --, 1e-08, --, --, --, --, --, --, --, 1e-08],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True,
                        True,  True, False],
           fill_value=1e+20), 'param_classifier:mlp:hidden_layer_depth': masked_array(data=[--, --, 3.0, --, --, --, --, --, --, --, 1.0],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True,
                        True,  True, False],
           fill_value=1e+20), 'param_classifier:mlp:learning_rate_init': masked_array(data=[--, --, 0.00014375616988222174, --, --, --, --, --, --,
                       --, 0.007525773377111986],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True,
                        True,  True, False],
           fill_value=1e+20), 'param_classifier:mlp:n_iter_no_change': masked_array(data=[--, --, 32.0, --, --, --, --, --, --, --, 32.0],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True,
                        True,  True, False],
           fill_value=1e+20), 'param_classifier:mlp:num_nodes_per_layer': masked_array(data=[--, --, 229.0, --, --, --, --, --, --, --, 224.0],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True,
                        True,  True, False],
           fill_value=1e+20), 'param_classifier:mlp:shuffle': masked_array(data=[--, --, 'True', --, --, --, --, --, --, --, 'True'],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True,
                        True,  True, False],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:mlp:solver': masked_array(data=[--, --, 'adam', --, --, --, --, --, --, --, 'adam'],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True,
                        True,  True, False],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:mlp:tol': masked_array(data=[--, --, 0.0001, --, --, --, --, --, --, --, 0.0001],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True,
                        True,  True, False],
           fill_value=1e+20), 'param_classifier:passive_aggressive:C': masked_array(data=[--, --, --, --, --, --, --, --, --,
                       0.009945692083946422, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True, False,  True],
           fill_value=1e+20), 'param_classifier:passive_aggressive:average': masked_array(data=[--, --, --, --, --, --, --, --, --, 'False', --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True, False,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:passive_aggressive:fit_intercept': masked_array(data=[--, --, --, --, --, --, --, --, --, 'True', --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True, False,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:passive_aggressive:loss': masked_array(data=[--, --, --, --, --, --, --, --, --, 'hinge', --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True, False,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:passive_aggressive:tol': masked_array(data=[--, --, --, --, --, --, --, --, --,
                       0.00039533312192938314, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True, False,  True],
           fill_value=1e+20), 'param_classifier:qda:reg_param': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:random_forest:bootstrap': masked_array(data=['True', 'True', --, --, --, --, --, --, --, --, --],
                 mask=[False, False,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:random_forest:criterion': masked_array(data=['gini', 'gini', --, --, --, --, --, --, --, --, --],
                 mask=[False, False,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:random_forest:max_depth': masked_array(data=['None', 'None', --, --, --, --, --, --, --, --, --],
                 mask=[False, False,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:random_forest:max_features': masked_array(data=[0.5, 0.9331254454871041, --, --, --, --, --, --, --,
                       --, --],
                 mask=[False, False,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20), 'param_classifier:random_forest:max_leaf_nodes': masked_array(data=['None', 'None', --, --, --, --, --, --, --, --, --],
                 mask=[False, False,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:random_forest:min_impurity_decrease': masked_array(data=[0.0, 0.0, --, --, --, --, --, --, --, --, --],
                 mask=[False, False,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20), 'param_classifier:random_forest:min_samples_leaf': masked_array(data=[1.0, 2.0, --, --, --, --, --, --, --, --, --],
                 mask=[False, False,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20), 'param_classifier:random_forest:min_samples_split': masked_array(data=[2.0, 20.0, --, --, --, --, --, --, --, --, --],
                 mask=[False, False,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20), 'param_classifier:random_forest:min_weight_fraction_leaf': masked_array(data=[0.0, 0.0, --, --, --, --, --, --, --, --, --],
                 mask=[False, False,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20), 'param_classifier:sgd:alpha': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:average': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:fit_intercept': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:learning_rate': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:loss': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:penalty': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:tol': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': masked_array(data=['one_hot_encoding', 'no_encoding', 'no_encoding',
                       'no_encoding', 'one_hot_encoding', 'no_encoding',
                       'one_hot_encoding', 'encoding', 'no_encoding',
                       'no_encoding', 'one_hot_encoding'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False],
           fill_value='N/A',
                dtype='<U16'), 'param_data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': masked_array(data=['minority_coalescer', 'minority_coalescer',
                       'minority_coalescer', 'minority_coalescer',
                       'minority_coalescer', 'no_coalescense',
                       'minority_coalescer', 'minority_coalescer',
                       'no_coalescense', 'no_coalescense', 'no_coalescense'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False],
           fill_value='N/A',
                dtype='<U18'), 'param_data_preprocessor:feature_type:numerical_transformer:imputation:strategy': masked_array(data=['mean', 'mean', 'most_frequent', 'mean', 'mean',
                       'mean', 'most_frequent', 'median', 'median',
                       'most_frequent', 'most_frequent'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False],
           fill_value='N/A',
                dtype='<U13'), 'param_data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': masked_array(data=['standardize', 'none', 'quantile_transformer',
                       'normalize', 'minmax', 'power_transformer',
                       'quantile_transformer', 'quantile_transformer',
                       'minmax', 'standardize', 'standardize'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False],
           fill_value='N/A',
                dtype='<U20'), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': masked_array(data=['bag_of_word_encoding', 'bag_of_word_encoding',
                       'bag_of_word_encoding', 'bag_of_word_encoding',
                       'bag_of_word_encoding',
                       'bag_of_word_encoding_distinct',
                       'bag_of_word_encoding', 'tfidf_encoding',
                       'tfidf_encoding', 'bag_of_word_encoding',
                       'tfidf_encoding'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False],
           fill_value='N/A',
                dtype='<U29'), 'param_data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': masked_array(data=[100, 100, 100, 100, 100, 137, 2, 15, 44, 1174, 5796],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False],
           fill_value=999999), 'param_feature_preprocessor:pca:keep_variance': masked_array(data=[0.9999, 0.9967857433838874, 0.7895711479212801,
                       0.8047274080856589, 0.9290439925152777,
                       0.9677965620214456, 0.5940439727806581,
                       0.9889862560610739, 0.8981112252440566,
                       0.9742266416789866, 0.8322479037809868],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False],
           fill_value=1e+20), 'param_feature_preprocessor:pca:whiten': masked_array(data=['False', 'False', 'True', 'False', 'False', 'False',
                       'True', 'False', 'True', 'False', 'False'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False],
           fill_value='N/A',
                dtype='<U5'), 'param_classifier:gradient_boosting:n_iter_no_change': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:gradient_boosting:validation_fraction': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:lda:shrinkage_factor': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:libsvm_svc:coef0': masked_array(data=[--, --, --, --, 0.08087614244138486, --, --, --, --,
                       --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20), 'param_classifier:libsvm_svc:degree': masked_array(data=[--, --, --, --, 3.0, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20), 'param_classifier:mlp:validation_fraction': masked_array(data=[--, --, 0.1, --, --, --, --, --, --, --, --],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20), 'param_classifier:sgd:epsilon': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:eta0': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:l1_ratio': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:power_t': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': masked_array(data=[0.01, 0.005069923784737444, 0.002766772136115771,
                       0.008015420020402715, 0.010000000000000004, --,
                       0.000603245839093932, 0.016731911468974733, --, --, --],
                 mask=[False, False, False, False, False,  True, False, False,
                        True,  True,  True],
           fill_value=1e+20), 'param_data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:n_quantiles': masked_array(data=[--, --, 180.0, --, --, --, 1660.0, 373.0, --, --, --],
                 mask=[ True,  True, False,  True,  True,  True, False, False,
                        True,  True,  True],
           fill_value=1e+20), 'param_data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:output_distribution': masked_array(data=[--, --, 'uniform', --, --, --, 'normal', 'uniform', --,
                       --, --],
                 mask=[ True,  True, False,  True,  True,  True, False, False,
                        True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_max': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_min': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': masked_array(data=['min_df_absolute', 'min_df_absolute',
                       'min_df_absolute', 'min_df_absolute',
                       'min_df_absolute', --, 'min_df_relative', --, --,
                       'min_df_absolute', --],
                 mask=[False, False, False, False, False,  True, False,  True,
                        True, False,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': masked_array(data=[1.0, 1.0, 1.0, 1.0, 1.0, --, 1.0, --, --, 3.0, --],
                 mask=[False, False, False, False, False,  True, False,  True,
                        True, False,  True],
           fill_value=1e+20), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:min_df_choice': masked_array(data=[--, --, --, --, --, 'min_df_relative', --, --, --, --,
                       --],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:ngram_upper_bound': masked_array(data=[--, --, --, --, --, 1.0, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True],
           fill_value=1e+20), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:min_df_choice': masked_array(data=[--, --, --, --, --, --, --, 'min_df_relative',
                       'min_df_absolute', --, 'min_df_absolute'],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False,
                       False,  True, False],
           fill_value='N/A',
                dtype='<U32'), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:ngram_upper_bound': masked_array(data=[--, --, --, --, --, --, --, 2.0, 2.0, --, 3.0],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False,
                       False,  True, False],
           fill_value=1e+20), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:use_idf': masked_array(data=[--, --, --, --, --, --, --, 0.0, 1.0, --, 0.0],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False,
                       False,  True, False],
           fill_value=1e+20), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': masked_array(data=[0.0, 1.0, 1.0, 1.0, 1.0, --, --, --, --, 9.0, --],
                 mask=[False, False, False, False, False,  True,  True,  True,
                        True, False,  True],
           fill_value=1e+20), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_relative': masked_array(data=[--, --, --, --, --, --, 0.36019594124973353, --, --,
                       --, --],
                 mask=[ True,  True,  True,  True,  True,  True, False,  True,
                        True,  True,  True],
           fill_value=1e+20), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:min_df_absolute': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:min_df_relative': masked_array(data=[--, --, --, --, --, 0.08656832316003299, --, --, --,
                       --, --],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True],
           fill_value=1e+20), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:min_df_absolute': masked_array(data=[--, --, --, --, --, --, --, --, 6.0, --, 2.0],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                       False,  True, False],
           fill_value=1e+20), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:min_df_relative': masked_array(data=[--, --, --, --, --, --, --, 0.0969631806397533, --, --,
                       --],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False,
                        True,  True,  True],
           fill_value=1e+20)}




.. GENERATED FROM PYTHON SOURCE LINES 181-186

Inspect the components of the best model
========================================

Iterate over the components of the model and print
The explained variance ratio per stage

.. GENERATED FROM PYTHON SOURCE LINES 186-199

.. code-block:: default

    for i, (weight, pipeline) in enumerate(automl.get_models_with_weights()):
        for stage_name, component in pipeline.named_steps.items():
            if "feature_preprocessor" in stage_name:
                print(
                    "The {}th pipeline has a explained variance of {}".format(
                        i,
                        # The component is an instance of AutoSklearnChoice.
                        # Access the sklearn object via the choice attribute
                        # We want the explained variance attributed of
                        # each principal component
                        component.choice.preprocessor.explained_variance_ratio_,
                    )
                )




.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    The 0th pipeline has a explained variance of [0.46038401 0.16124884]
    The 1th pipeline has a explained variance of [0.44685232 0.17122959 0.1085501  0.07063243 0.06437417 0.03986668
     0.02462169 0.01589975 0.01257378 0.00948519 0.00858029]
    The 2th pipeline has a explained variance of [0.49503611 0.16649281 0.09111888 0.07213284 0.04865917 0.03208923]
    The 3th pipeline has a explained variance of [0.45954164 0.18010277 0.09814953 0.06334655]
    The 4th pipeline has a explained variance of [0.98080571 0.01684553]
    The 5th pipeline has a explained variance of [0.43295688 0.1790573  0.11173757 0.06807243 0.05946115 0.03706299
     0.0238431  0.01493261 0.01376414 0.01137049 0.01037373 0.00874117
     0.0075763 ]
    The 6th pipeline has a explained variance of [4.32956881e-01 1.79057296e-01 1.11737571e-01 6.80724345e-02
     5.94611519e-02 3.70629898e-02 2.38430977e-02 1.49326086e-02
     1.37641366e-02 1.13704890e-02 1.03737258e-02 8.74116751e-03
     7.57629717e-03 4.86528503e-03 3.32225143e-03 2.55773043e-03
     2.20759805e-03 1.88675402e-03 1.36245140e-03 1.03409213e-03
     8.39749085e-04 7.91287172e-04 6.75655689e-04 5.42961621e-04
     5.02641737e-04 2.07827509e-04 1.74597367e-04]
    The 7th pipeline has a explained variance of [0.49503611 0.16649281 0.09111888 0.07213284 0.04865917 0.03208923
     0.01851537 0.01223987]
    The 8th pipeline has a explained variance of [0.76699224 0.17152095]





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  42.959 seconds)


.. _sphx_glr_download_examples_40_advanced_example_get_pipeline_components.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example


  .. container:: binder-badge

    .. image:: images/binder_badge_logo.svg
      :target: https://mybinder.org/v2/gh/automl/auto-sklearn/master?urlpath=lab/tree/notebooks/examples/40_advanced/example_get_pipeline_components.ipynb
      :alt: Launch binder
      :width: 150 px


  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: example_get_pipeline_components.py <example_get_pipeline_components.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: example_get_pipeline_components.ipynb <example_get_pipeline_components.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
