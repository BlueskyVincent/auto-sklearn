
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/40_advanced/example_multi_objective.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_40_advanced_example_multi_objective.py>`
        to download the full example code or to run this example in your browser via Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_40_advanced_example_multi_objective.py:


==============
Classification
==============

The following example shows how to fit *auto-sklearn* to optimize for two
competing metrics: `precision` and `recall` (read more on this tradeoff
in the `scikit-learn docs <https://scikit-learn.org/stable/auto_examples/model_selection/plot_precision_recall.html>`_.

Auto-sklearn uses `SMAC3's implementation of ParEGO <https://automl.github.io/SMAC3/main/details/multi_objective.html>`_.
Multi-objective ensembling and proper access to the full Pareto set will be added in the near
future.

.. GENERATED FROM PYTHON SOURCE LINES 15-26

.. code-block:: default

    from pprint import pprint

    import matplotlib.pyplot as plt
    import numpy as np
    import sklearn.datasets
    import sklearn.metrics

    import autosklearn.classification
    import autosklearn.metrics









.. GENERATED FROM PYTHON SOURCE LINES 27-29

Data Loading
============

.. GENERATED FROM PYTHON SOURCE LINES 29-39

.. code-block:: default


    X, y = sklearn.datasets.fetch_openml(data_id=31, return_X_y=True, as_frame=True)
    # Change the target to align with scikit-learn's convention that
    # ``1`` is the minority class. In this example it is predicting
    # that a credit is "bad", i.e. that it will default.
    y = np.array([1 if val == "bad" else 0 for val in y])
    X_train, X_test, y_train, y_test = sklearn.model_selection.train_test_split(
        X, y, random_state=1
    )








.. GENERATED FROM PYTHON SOURCE LINES 40-42

Build and fit a classifier
==========================

.. GENERATED FROM PYTHON SOURCE LINES 42-50

.. code-block:: default


    automl = autosklearn.classification.AutoSklearnClassifier(
        time_left_for_this_task=120,
        metric=[autosklearn.metrics.precision, autosklearn.metrics.recall],
        delete_tmp_folder_after_terminate=False,
    )
    automl.fit(X_train, y_train, dataset_name="German Credit")





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    AutoSklearnClassifier(delete_tmp_folder_after_terminate=False,
                          metric=[precision, recall], per_run_time_limit=12,
                          time_left_for_this_task=120)



.. GENERATED FROM PYTHON SOURCE LINES 51-53

Compute the two competing metrics
=================================

.. GENERATED FROM PYTHON SOURCE LINES 53-58

.. code-block:: default


    predictions = automl.predict(X_test)
    print("Precision", sklearn.metrics.precision_score(y_test, predictions))
    print("Recall", sklearn.metrics.recall_score(y_test, predictions))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Precision 0.6956521739130435
    Recall 0.21621621621621623




.. GENERATED FROM PYTHON SOURCE LINES 59-62

View the models found by auto-sklearn
=====================================
They are by default sorted by the first metric given to *auto-sklearn*.

.. GENERATED FROM PYTHON SOURCE LINES 62-65

.. code-block:: default


    print(automl.leaderboard())





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

              rank  ensemble_weight           type    cost_0    cost_1  duration
    model_id                                                                    
    2            2             0.14  random_forest  0.311111  0.586667  2.391096
    3            4             0.02    extra_trees  0.385965  0.533333  2.239119
    16           3             0.56    extra_trees  0.375000  0.933333  2.417643
    21           1             0.24  random_forest  0.205128  0.586667  2.335537
    22           5             0.04       adaboost  0.555556  0.306667  2.052898




.. GENERATED FROM PYTHON SOURCE LINES 66-70

``cv_results`` also contains both metrics
=========================================
Similarly to the leaderboard, they are sorted by the first metric given
to *auto-sklearn*.

.. GENERATED FROM PYTHON SOURCE LINES 70-73

.. code-block:: default


    pprint(automl.cv_results_)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    {'budgets': [0.0,
                 0.0,
                 0.0,
                 0.0,
                 0.0,
                 0.0,
                 0.0,
                 0.0,
                 0.0,
                 0.0,
                 0.0,
                 0.0,
                 0.0,
                 0.0,
                 0.0,
                 0.0,
                 0.0,
                 0.0,
                 0.0,
                 0.0,
                 0.0,
                 0.0,
                 0.0,
                 0.0,
                 0.0],
     'mean_fit_time': array([ 2.39109612,  2.23911881,  2.18720031,  2.30295396,  2.88856149,
            4.28515291,  2.2251358 ,  1.32215643,  2.37642169, 12.01295161,
            1.73926044,  2.52455902,  1.90113735,  1.01339579,  2.41764283,
            1.27570057,  5.28539395,  1.47541308, 10.29567885,  2.33553672,
            2.05289841,  1.02673626,  2.6742568 ,  2.49802804,  1.0081718 ]),
     'mean_test_precision': array([0.68888889, 0.61403509, 0.42156863, 0.55072464, 0.56666667,
           0.70588235, 0.67391304, 0.453125  , 0.51401869, 0.        ,
           0.49090909, 0.55263158, 0.50526316, 0.59016393, 0.625     ,
           0.        , 0.47222222, 0.47272727, 0.54117647, 0.79487179,
           0.44444444, 0.        , 0.52040816, 0.49593496, 0.        ]),
     'mean_test_recall': array([0.41333333, 0.46666667, 0.57333333, 0.50666667, 0.22666667,
           0.48      , 0.41333333, 0.38666667, 0.73333333, 0.        ,
           0.72      , 0.28      , 0.64      , 0.48      , 0.06666667,
           0.        , 0.45333333, 0.34666667, 0.61333333, 0.41333333,
           0.69333333, 0.        , 0.68      , 0.81333333, 0.        ]),
     'param_balancing:strategy': masked_array(data=['none', 'none', 'weighting', 'weighting', 'weighting',
                       'weighting', 'none', 'weighting', 'weighting',
                       'weighting', 'weighting', 'none', 'weighting', 'none',
                       'none', 'weighting', 'weighting', 'none', 'weighting',
                       'none', 'weighting', 'none', 'weighting', 'weighting',
                       'weighting'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False],
           fill_value='N/A',
                dtype='<U9'),
     'param_classifier:__choice__': masked_array(data=['random_forest', 'extra_trees', 'extra_trees',
                       'gradient_boosting', 'random_forest', 'mlp',
                       'random_forest', 'passive_aggressive', 'random_forest',
                       'libsvm_svc', 'gradient_boosting', 'mlp',
                       'gradient_boosting', 'sgd', 'extra_trees', 'lda',
                       'extra_trees', 'mlp', 'gradient_boosting',
                       'random_forest', 'adaboost', 'passive_aggressive',
                       'random_forest', 'extra_trees', 'mlp'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False],
           fill_value='N/A',
                dtype='<U18'),
     'param_classifier:adaboost:algorithm': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, 'SAMME', --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True, False,  True,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:adaboost:learning_rate': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, 0.2844845910527844, --, --, --,
                       --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True, False,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_classifier:adaboost:max_depth': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, 2.0, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True, False,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_classifier:adaboost:n_estimators': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, 370.0, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True, False,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_classifier:bernoulli_nb:alpha': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:bernoulli_nb:fit_prior': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:decision_tree:criterion': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:decision_tree:max_depth_factor': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:decision_tree:max_features': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:decision_tree:max_leaf_nodes': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:decision_tree:min_impurity_decrease': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:decision_tree:min_samples_leaf': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:decision_tree:min_samples_split': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:decision_tree:min_weight_fraction_leaf': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:extra_trees:bootstrap': masked_array(data=[--, 'True', 'False', --, --, --, --, --, --, --, --,
                       --, --, --, 'True', --, 'False', --, --, --, --, --,
                       --, 'False', --],
                 mask=[ True, False, False,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False,  True,
                       False,  True,  True,  True,  True,  True,  True, False,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:extra_trees:criterion': masked_array(data=[--, 'entropy', 'entropy', --, --, --, --, --, --, --,
                       --, --, --, --, 'entropy', --, 'entropy', --, --, --,
                       --, --, --, 'gini', --],
                 mask=[ True, False, False,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False,  True,
                       False,  True,  True,  True,  True,  True,  True, False,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:extra_trees:max_depth': masked_array(data=[--, 'None', 'None', --, --, --, --, --, --, --, --, --,
                       --, --, 'None', --, 'None', --, --, --, --, --, --,
                       'None', --],
                 mask=[ True, False, False,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False,  True,
                       False,  True,  True,  True,  True,  True,  True, False,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:extra_trees:max_features': masked_array(data=[--, 0.5, 0.7655092431692035, --, --, --, --, --, --,
                       --, --, --, --, --, 0.15687109796165688, --,
                       0.993803313878608, --, --, --, --, --, --,
                       0.36338266699494315, --],
                 mask=[ True, False, False,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False,  True,
                       False,  True,  True,  True,  True,  True,  True, False,
                        True],
           fill_value=1e+20),
     'param_classifier:extra_trees:max_leaf_nodes': masked_array(data=[--, 'None', 'None', --, --, --, --, --, --, --, --, --,
                       --, --, 'None', --, 'None', --, --, --, --, --, --,
                       'None', --],
                 mask=[ True, False, False,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False,  True,
                       False,  True,  True,  True,  True,  True,  True, False,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:extra_trees:min_impurity_decrease': masked_array(data=[--, 0.0, 0.0, --, --, --, --, --, --, --, --, --, --,
                       --, 0.0, --, 0.0, --, --, --, --, --, --, 0.0, --],
                 mask=[ True, False, False,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False,  True,
                       False,  True,  True,  True,  True,  True,  True, False,
                        True],
           fill_value=1e+20),
     'param_classifier:extra_trees:min_samples_leaf': masked_array(data=[--, 1.0, 19.0, --, --, --, --, --, --, --, --, --, --,
                       --, 3.0, --, 2.0, --, --, --, --, --, --, 10.0, --],
                 mask=[ True, False, False,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False,  True,
                       False,  True,  True,  True,  True,  True,  True, False,
                        True],
           fill_value=1e+20),
     'param_classifier:extra_trees:min_samples_split': masked_array(data=[--, 2.0, 5.0, --, --, --, --, --, --, --, --, --, --,
                       --, 13.0, --, 20.0, --, --, --, --, --, --, 5.0, --],
                 mask=[ True, False, False,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False,  True,
                       False,  True,  True,  True,  True,  True,  True, False,
                        True],
           fill_value=1e+20),
     'param_classifier:extra_trees:min_weight_fraction_leaf': masked_array(data=[--, 0.0, 0.0, --, --, --, --, --, --, --, --, --, --,
                       --, 0.0, --, 0.0, --, --, --, --, --, --, 0.0, --],
                 mask=[ True, False, False,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False,  True,
                       False,  True,  True,  True,  True,  True,  True, False,
                        True],
           fill_value=1e+20),
     'param_classifier:gradient_boosting:early_stop': masked_array(data=[--, --, --, 'train', --, --, --, --, --, --, 'train',
                       --, 'off', --, --, --, --, --, 'train', --, --, --, --,
                       --, --],
                 mask=[ True,  True,  True, False,  True,  True,  True,  True,
                        True,  True, False,  True, False,  True,  True,  True,
                        True,  True, False,  True,  True,  True,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:gradient_boosting:l2_regularization': masked_array(data=[--, --, --, 3.387912939529945e-10, --, --, --, --, --,
                       --, 0.20982857192812085, --, 5.195231690836764e-09, --,
                       --, --, --, --, 0.05488841601458162, --, --, --, --,
                       --, --],
                 mask=[ True,  True,  True, False,  True,  True,  True,  True,
                        True,  True, False,  True, False,  True,  True,  True,
                        True,  True, False,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_classifier:gradient_boosting:learning_rate': masked_array(data=[--, --, --, 0.30755227194768237, --, --, --, --, --,
                       --, 0.012770531206809599, --, 0.06101786517649655, --,
                       --, --, --, --, 0.0843846716858782, --, --, --, --, --,
                       --],
                 mask=[ True,  True,  True, False,  True,  True,  True,  True,
                        True,  True, False,  True, False,  True,  True,  True,
                        True,  True, False,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_classifier:gradient_boosting:loss': masked_array(data=[--, --, --, 'auto', --, --, --, --, --, --, 'auto', --,
                       'auto', --, --, --, --, --, 'auto', --, --, --, --, --,
                       --],
                 mask=[ True,  True,  True, False,  True,  True,  True,  True,
                        True,  True, False,  True, False,  True,  True,  True,
                        True,  True, False,  True,  True,  True,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:gradient_boosting:max_bins': masked_array(data=[--, --, --, 255.0, --, --, --, --, --, --, 255.0, --,
                       255.0, --, --, --, --, --, 255.0, --, --, --, --, --,
                       --],
                 mask=[ True,  True,  True, False,  True,  True,  True,  True,
                        True,  True, False,  True, False,  True,  True,  True,
                        True,  True, False,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_classifier:gradient_boosting:max_depth': masked_array(data=[--, --, --, 'None', --, --, --, --, --, --, 'None', --,
                       'None', --, --, --, --, --, 'None', --, --, --, --, --,
                       --],
                 mask=[ True,  True,  True, False,  True,  True,  True,  True,
                        True,  True, False,  True, False,  True,  True,  True,
                        True,  True, False,  True,  True,  True,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:gradient_boosting:max_leaf_nodes': masked_array(data=[--, --, --, 60.0, --, --, --, --, --, --, 32.0, --,
                       10.0, --, --, --, --, --, 4.0, --, --, --, --, --, --],
                 mask=[ True,  True,  True, False,  True,  True,  True,  True,
                        True,  True, False,  True, False,  True,  True,  True,
                        True,  True, False,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_classifier:gradient_boosting:min_samples_leaf': masked_array(data=[--, --, --, 39.0, --, --, --, --, --, --, 69.0, --,
                       22.0, --, --, --, --, --, 3.0, --, --, --, --, --, --],
                 mask=[ True,  True,  True, False,  True,  True,  True,  True,
                        True,  True, False,  True, False,  True,  True,  True,
                        True,  True, False,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_classifier:gradient_boosting:n_iter_no_change': masked_array(data=[--, --, --, 18.0, --, --, --, --, --, --, 19.0, --, --,
                       --, --, --, --, --, 16.0, --, --, --, --, --, --],
                 mask=[ True,  True,  True, False,  True,  True,  True,  True,
                        True,  True, False,  True,  True,  True,  True,  True,
                        True,  True, False,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_classifier:gradient_boosting:scoring': masked_array(data=[--, --, --, 'loss', --, --, --, --, --, --, 'loss', --,
                       'loss', --, --, --, --, --, 'loss', --, --, --, --, --,
                       --],
                 mask=[ True,  True,  True, False,  True,  True,  True,  True,
                        True,  True, False,  True, False,  True,  True,  True,
                        True,  True, False,  True,  True,  True,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:gradient_boosting:tol': masked_array(data=[--, --, --, 1e-07, --, --, --, --, --, --, 1e-07, --,
                       1e-07, --, --, --, --, --, 1e-07, --, --, --, --, --,
                       --],
                 mask=[ True,  True,  True, False,  True,  True,  True,  True,
                        True,  True, False,  True, False,  True,  True,  True,
                        True,  True, False,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_classifier:gradient_boosting:validation_fraction': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:k_nearest_neighbors:n_neighbors': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:k_nearest_neighbors:p': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:k_nearest_neighbors:weights': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:lda:shrinkage': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, 'auto', --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True, False,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:lda:shrinkage_factor': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:lda:tol': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, 0.06502391592449622, --, --, --, --, --, --, --,
                       --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True, False,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_classifier:liblinear_svc:C': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:liblinear_svc:dual': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:liblinear_svc:fit_intercept': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:liblinear_svc:intercept_scaling': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:liblinear_svc:loss': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:liblinear_svc:multi_class': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:liblinear_svc:penalty': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:liblinear_svc:tol': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:libsvm_svc:C': masked_array(data=[--, --, --, --, --, --, --, --, --, 2176.2897327948685,
                       --, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_classifier:libsvm_svc:coef0': masked_array(data=[--, --, --, --, --, --, --, --, --,
                       -0.018575725453357728, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_classifier:libsvm_svc:degree': masked_array(data=[--, --, --, --, --, --, --, --, --, 2.0, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_classifier:libsvm_svc:gamma': masked_array(data=[--, --, --, --, --, --, --, --, --,
                       0.006276539842771683, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_classifier:libsvm_svc:kernel': masked_array(data=[--, --, --, --, --, --, --, --, --, 'poly', --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:libsvm_svc:max_iter': masked_array(data=[--, --, --, --, --, --, --, --, --, -1.0, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_classifier:libsvm_svc:shrinking': masked_array(data=[--, --, --, --, --, --, --, --, --, 'False', --, --,
                       --, --, --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:libsvm_svc:tol': masked_array(data=[--, --, --, --, --, --, --, --, --,
                       7.288971711473298e-05, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_classifier:mlp:activation': masked_array(data=[--, --, --, --, --, 'tanh', --, --, --, --, --, 'tanh',
                       --, --, --, --, --, 'relu', --, --, --, --, --, --,
                       'tanh'],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                       False],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:mlp:alpha': masked_array(data=[--, --, --, --, --, 0.00021148999718383549, --, --, --,
                       --, --, 0.0001363185819149026, --, --, --, --, --,
                       4.073424522787473e-06, --, --, --, --, --, --,
                       0.000105725428203196],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                       False],
           fill_value=1e+20),
     'param_classifier:mlp:batch_size': masked_array(data=[--, --, --, --, --, 'auto', --, --, --, --, --, 'auto',
                       --, --, --, --, --, 'auto', --, --, --, --, --, --,
                       'auto'],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                       False],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:mlp:beta_1': masked_array(data=[--, --, --, --, --, 0.9, --, --, --, --, --, 0.9, --,
                       --, --, --, --, 0.9, --, --, --, --, --, --, 0.9],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                       False],
           fill_value=1e+20),
     'param_classifier:mlp:beta_2': masked_array(data=[--, --, --, --, --, 0.999, --, --, --, --, --, 0.999,
                       --, --, --, --, --, 0.999, --, --, --, --, --, --,
                       0.999],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                       False],
           fill_value=1e+20),
     'param_classifier:mlp:early_stopping': masked_array(data=[--, --, --, --, --, 'train', --, --, --, --, --,
                       'valid', --, --, --, --, --, 'valid', --, --, --, --,
                       --, --, 'valid'],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                       False],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:mlp:epsilon': masked_array(data=[--, --, --, --, --, 1e-08, --, --, --, --, --, 1e-08,
                       --, --, --, --, --, 1e-08, --, --, --, --, --, --,
                       1e-08],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                       False],
           fill_value=1e+20),
     'param_classifier:mlp:hidden_layer_depth': masked_array(data=[--, --, --, --, --, 3.0, --, --, --, --, --, 3.0, --,
                       --, --, --, --, 3.0, --, --, --, --, --, --, 3.0],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                       False],
           fill_value=1e+20),
     'param_classifier:mlp:learning_rate_init': masked_array(data=[--, --, --, --, --, 0.0007452270241186694, --, --, --,
                       --, --, 0.00018009776276177523, --, --, --, --, --,
                       0.0059180455768467425, --, --, --, --, --, --,
                       0.0010000000000000002],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                       False],
           fill_value=1e+20),
     'param_classifier:mlp:n_iter_no_change': masked_array(data=[--, --, --, --, --, 32.0, --, --, --, --, --, 32.0, --,
                       --, --, --, --, 32.0, --, --, --, --, --, --, 32.0],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                       False],
           fill_value=1e+20),
     'param_classifier:mlp:num_nodes_per_layer': masked_array(data=[--, --, --, --, --, 113.0, --, --, --, --, --, 115.0,
                       --, --, --, --, --, 27.0, --, --, --, --, --, --, 32.0],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                       False],
           fill_value=1e+20),
     'param_classifier:mlp:shuffle': masked_array(data=[--, --, --, --, --, 'True', --, --, --, --, --, 'True',
                       --, --, --, --, --, 'True', --, --, --, --, --, --,
                       'True'],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                       False],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:mlp:solver': masked_array(data=[--, --, --, --, --, 'adam', --, --, --, --, --, 'adam',
                       --, --, --, --, --, 'adam', --, --, --, --, --, --,
                       'adam'],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                       False],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:mlp:tol': masked_array(data=[--, --, --, --, --, 0.0001, --, --, --, --, --, 0.0001,
                       --, --, --, --, --, 0.0001, --, --, --, --, --, --,
                       0.0001],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                       False],
           fill_value=1e+20),
     'param_classifier:mlp:validation_fraction': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, 0.1, --,
                       --, --, --, --, 0.1, --, --, --, --, --, --, 0.1],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                       False],
           fill_value=1e+20),
     'param_classifier:multinomial_nb:alpha': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:multinomial_nb:fit_prior': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:passive_aggressive:C': masked_array(data=[--, --, --, --, --, --, --, 0.008807665845919431, --,
                       --, --, --, --, --, --, --, --, --, --, --, --, 1.0,
                       --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True, False,  True,  True,
                        True],
           fill_value=1e+20),
     'param_classifier:passive_aggressive:average': masked_array(data=[--, --, --, --, --, --, --, 'False', --, --, --, --,
                       --, --, --, --, --, --, --, --, --, 'True', --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True, False,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:passive_aggressive:fit_intercept': masked_array(data=[--, --, --, --, --, --, --, 'True', --, --, --, --, --,
                       --, --, --, --, --, --, --, --, 'True', --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True, False,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:passive_aggressive:loss': masked_array(data=[--, --, --, --, --, --, --, 'hinge', --, --, --, --,
                       --, --, --, --, --, --, --, --, --, 'hinge', --, --,
                       --],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True, False,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:passive_aggressive:tol': masked_array(data=[--, --, --, --, --, --, --, 0.001174447028725537, --,
                       --, --, --, --, --, --, --, --, --, --, --, --,
                       0.00010000000000000009, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True, False,  True,  True,
                        True],
           fill_value=1e+20),
     'param_classifier:qda:reg_param': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:random_forest:bootstrap': masked_array(data=['True', --, --, --, 'True', --, 'True', --, 'False',
                       --, --, --, --, --, --, --, --, --, --, 'True', --, --,
                       'False', --, --],
                 mask=[False,  True,  True,  True, False,  True, False,  True,
                       False,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True, False,  True,  True, False,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:random_forest:criterion': masked_array(data=['gini', --, --, --, 'gini', --, 'entropy', --,
                       'entropy', --, --, --, --, --, --, --, --, --, --,
                       'entropy', --, --, 'entropy', --, --],
                 mask=[False,  True,  True,  True, False,  True, False,  True,
                       False,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True, False,  True,  True, False,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:random_forest:max_depth': masked_array(data=['None', --, --, --, 'None', --, 'None', --, 'None', --,
                       --, --, --, --, --, --, --, --, --, 'None', --, --,
                       'None', --, --],
                 mask=[False,  True,  True,  True, False,  True, False,  True,
                       False,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True, False,  True,  True, False,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:random_forest:max_features': masked_array(data=[0.5, --, --, --, 0.48532133444855097, --,
                       0.4784709727277252, --, 0.8390317715938469, --, --, --,
                       --, --, --, --, --, --, --, 0.4678465140755959, --, --,
                       0.6008565943377931, --, --],
                 mask=[False,  True,  True,  True, False,  True, False,  True,
                       False,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True, False,  True,  True, False,  True,
                        True],
           fill_value=1e+20),
     'param_classifier:random_forest:max_leaf_nodes': masked_array(data=['None', --, --, --, 'None', --, 'None', --, 'None', --,
                       --, --, --, --, --, --, --, --, --, 'None', --, --,
                       'None', --, --],
                 mask=[False,  True,  True,  True, False,  True, False,  True,
                       False,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True, False,  True,  True, False,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:random_forest:min_impurity_decrease': masked_array(data=[0.0, --, --, --, 0.0, --, 0.0, --, 0.0, --, --, --, --,
                       --, --, --, --, --, --, 0.0, --, --, 0.0, --, --],
                 mask=[False,  True,  True,  True, False,  True, False,  True,
                       False,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True, False,  True,  True, False,  True,
                        True],
           fill_value=1e+20),
     'param_classifier:random_forest:min_samples_leaf': masked_array(data=[1.0, --, --, --, 1.0, --, 1.0, --, 14.0, --, --, --,
                       --, --, --, --, --, --, --, 1.0, --, --, 4.0, --, --],
                 mask=[False,  True,  True,  True, False,  True, False,  True,
                       False,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True, False,  True,  True, False,  True,
                        True],
           fill_value=1e+20),
     'param_classifier:random_forest:min_samples_split': masked_array(data=[2.0, --, --, --, 2.0, --, 14.0, --, 6.0, --, --, --,
                       --, --, --, --, --, --, --, 2.0, --, --, 2.0, --, --],
                 mask=[False,  True,  True,  True, False,  True, False,  True,
                       False,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True, False,  True,  True, False,  True,
                        True],
           fill_value=1e+20),
     'param_classifier:random_forest:min_weight_fraction_leaf': masked_array(data=[0.0, --, --, --, 0.0, --, 0.0, --, 0.0, --, --, --, --,
                       --, --, --, --, --, --, 0.0, --, --, 0.0, --, --],
                 mask=[False,  True,  True,  True, False,  True, False,  True,
                       False,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True, False,  True,  True, False,  True,
                        True],
           fill_value=1e+20),
     'param_classifier:sgd:alpha': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --,
                       2.8077187575610757e-05, --, --, --, --, --, --, --, --,
                       --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_classifier:sgd:average': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --,
                       'True', --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:sgd:epsilon': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:sgd:eta0': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:sgd:fit_intercept': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --,
                       'True', --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:sgd:l1_ratio': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --,
                       0.275125886570793, --, --, --, --, --, --, --, --, --,
                       --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_classifier:sgd:learning_rate': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --,
                       'optimal', --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:sgd:loss': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --,
                       'log', --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:sgd:penalty': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --,
                       'elasticnet', --, --, --, --, --, --, --, --, --, --,
                       --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:sgd:power_t': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:sgd:tol': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --,
                       1.3351064406792789e-05, --, --, --, --, --, --, --, --,
                       --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_data_preprocessor:__choice__': masked_array(data=['feature_type', 'feature_type', 'feature_type',
                       'feature_type', 'feature_type', 'feature_type',
                       'feature_type', 'feature_type', 'feature_type',
                       'feature_type', 'feature_type', 'feature_type',
                       'feature_type', 'feature_type', 'feature_type',
                       'feature_type', 'feature_type', 'feature_type',
                       'feature_type', 'feature_type', 'feature_type',
                       'feature_type', 'feature_type', 'feature_type',
                       'feature_type'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False],
           fill_value='N/A',
                dtype='<U12'),
     'param_data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': masked_array(data=['one_hot_encoding', 'no_encoding', 'one_hot_encoding',
                       'one_hot_encoding', 'no_encoding', 'one_hot_encoding',
                       'no_encoding', 'one_hot_encoding', 'one_hot_encoding',
                       'one_hot_encoding', 'no_encoding', 'no_encoding',
                       'no_encoding', 'one_hot_encoding', 'one_hot_encoding',
                       'no_encoding', 'no_encoding', 'no_encoding',
                       'one_hot_encoding', 'one_hot_encoding', 'no_encoding',
                       'no_encoding', 'no_encoding', 'no_encoding',
                       'no_encoding'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False],
           fill_value='N/A',
                dtype='<U16'),
     'param_data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': masked_array(data=['minority_coalescer', 'minority_coalescer',
                       'no_coalescense', 'minority_coalescer',
                       'minority_coalescer', 'no_coalescense',
                       'no_coalescense', 'minority_coalescer',
                       'minority_coalescer', 'minority_coalescer',
                       'minority_coalescer', 'no_coalescense',
                       'no_coalescense', 'no_coalescense', 'no_coalescense',
                       'minority_coalescer', 'minority_coalescer',
                       'minority_coalescer', 'no_coalescense',
                       'minority_coalescer', 'minority_coalescer',
                       'minority_coalescer', 'no_coalescense',
                       'no_coalescense', 'no_coalescense'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False],
           fill_value='N/A',
                dtype='<U18'),
     'param_data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': masked_array(data=[0.01, 0.1040851795596776, --, 0.010000000000000004,
                       0.010000000000000004, --, --, 0.42677247105834165,
                       0.15465886171097135, 0.010000000000000004,
                       0.0005589708287942353, --, --, --, --,
                       0.025659060146568036, 0.41826215858914706,
                       0.00029426245080363384, --, 0.033371278314588006,
                       0.3519795567275179, 0.010000000000000004, --, --, --],
                 mask=[False, False,  True, False, False,  True,  True, False,
                       False, False, False,  True,  True,  True,  True, False,
                       False, False,  True, False, False, False,  True,  True,
                        True],
           fill_value=1e+20),
     'param_data_preprocessor:feature_type:numerical_transformer:imputation:strategy': masked_array(data=['mean', 'most_frequent', 'most_frequent',
                       'most_frequent', 'mean', 'most_frequent',
                       'most_frequent', 'most_frequent', 'mean', 'median',
                       'mean', 'median', 'median', 'most_frequent', 'median',
                       'median', 'median', 'most_frequent', 'mean',
                       'most_frequent', 'median', 'median', 'mean', 'median',
                       'mean'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False],
           fill_value='N/A',
                dtype='<U13'),
     'param_data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': masked_array(data=['standardize', 'none', 'normalize', 'none', 'minmax',
                       'standardize', 'none', 'robust_scaler',
                       'robust_scaler', 'robust_scaler', 'robust_scaler',
                       'standardize', 'robust_scaler', 'standardize',
                       'quantile_transformer', 'robust_scaler',
                       'robust_scaler', 'standardize', 'quantile_transformer',
                       'quantile_transformer', 'standardize', 'none',
                       'robust_scaler', 'none', 'robust_scaler'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False],
           fill_value='N/A',
                dtype='<U20'),
     'param_data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:n_quantiles': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       1643.0, --, --, --, 654.0, 1000.0, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False,  True,
                        True,  True, False, False,  True,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:output_distribution': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       'uniform', --, --, --, 'uniform', 'uniform', --, --,
                       --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False,  True,
                        True,  True, False, False,  True,  True,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_max': masked_array(data=[--, --, --, --, --, --, --, 0.7278293151795671,
                       0.7083522758919695, 0.75, 0.9803466242807123, --,
                       0.7633589611863135, --, --, 0.75, 0.7305615609807856,
                       --, --, --, --, --, 0.9807302775111806, --,
                       0.8650501969026246],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False,
                       False, False, False,  True, False,  True,  True, False,
                       False,  True,  True,  True,  True,  True, False,  True,
                       False],
           fill_value=1e+20),
     'param_data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_min': masked_array(data=[--, --, --, --, --, --, --, 0.16271852122755062,
                       0.26017575741727234, 0.2058549350571071,
                       0.1005590641662353, --, 0.29630657165502694, --, --,
                       0.2479524799615851, 0.25595970768123566, --, --, --,
                       --, --, 0.2839332787950659, --, 0.19685017087313914],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False,
                       False, False, False,  True, False,  True,  True, False,
                       False,  True,  True,  True,  True,  True, False,  True,
                       False],
           fill_value=1e+20),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': masked_array(data=['bag_of_word_encoding', 'bag_of_word_encoding',
                       'bag_of_word_encoding', 'bag_of_word_encoding',
                       'bag_of_word_encoding', 'bag_of_word_encoding',
                       'bag_of_word_encoding', 'bag_of_word_encoding',
                       'bag_of_word_encoding', 'bag_of_word_encoding',
                       'bag_of_word_encoding', 'bag_of_word_encoding',
                       'bag_of_word_encoding', 'bag_of_word_encoding',
                       'bag_of_word_encoding', 'bag_of_word_encoding',
                       'bag_of_word_encoding', 'bag_of_word_encoding',
                       'bag_of_word_encoding', 'bag_of_word_encoding',
                       'bag_of_word_encoding', 'bag_of_word_encoding',
                       'bag_of_word_encoding',
                       'bag_of_word_encoding_distinct',
                       'bag_of_word_encoding_distinct'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False],
           fill_value='N/A',
                dtype='<U29'),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': masked_array(data=[0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
                       1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
                       6.0, --, --],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False,  True,
                        True],
           fill_value=1e+20),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': masked_array(data=['min_df_absolute', 'min_df_absolute',
                       'min_df_absolute', 'min_df_absolute',
                       'min_df_absolute', 'min_df_absolute',
                       'min_df_absolute', 'min_df_absolute',
                       'min_df_absolute', 'min_df_absolute',
                       'min_df_absolute', 'min_df_absolute',
                       'min_df_absolute', 'min_df_absolute',
                       'min_df_absolute', 'min_df_absolute',
                       'min_df_absolute', 'min_df_absolute',
                       'min_df_absolute', 'min_df_absolute',
                       'min_df_absolute', 'min_df_absolute',
                       'min_df_absolute', --, --],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_relative': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': masked_array(data=[1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
                       1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
                       3.0, --, --],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False,  True,
                        True],
           fill_value=1e+20),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:min_df_absolute': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:min_df_choice': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, 'min_df_relative',
                       'min_df_relative'],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True, False,
                       False],
           fill_value='N/A',
                dtype='<U32'),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:min_df_relative': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, 0.5081124812807862,
                       0.010000000000000004],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True, False,
                       False],
           fill_value=1e+20),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:ngram_upper_bound': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, 2.0, 1.0],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True, False,
                       False],
           fill_value=1e+20),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:min_df_absolute': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:min_df_choice': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:min_df_relative': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:ngram_upper_bound': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:use_idf': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': masked_array(data=[100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
                       100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
                       1, 6, 1004],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False],
           fill_value=999999),
     'param_feature_preprocessor:__choice__': masked_array(data=['no_preprocessing', 'select_rates_classification',
                       'liblinear_svc_preprocessor',
                       'select_percentile_classification', 'fast_ica',
                       'feature_agglomeration', 'select_rates_classification',
                       'fast_ica', 'select_percentile_classification',
                       'select_percentile_classification',
                       'select_rates_classification', 'feature_agglomeration',
                       'select_rates_classification', 'no_preprocessing',
                       'extra_trees_preproc_for_classification',
                       'select_rates_classification', 'polynomial',
                       'extra_trees_preproc_for_classification', 'polynomial',
                       'no_preprocessing', 'no_preprocessing',
                       'select_rates_classification',
                       'extra_trees_preproc_for_classification',
                       'extra_trees_preproc_for_classification',
                       'feature_agglomeration'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False],
           fill_value='N/A',
                dtype='<U38'),
     'param_feature_preprocessor:extra_trees_preproc_for_classification:bootstrap': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       'False', --, --, 'False', --, --, --, --, 'True',
                       'False', --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False,  True,
                        True, False,  True,  True,  True,  True, False, False,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:extra_trees_preproc_for_classification:criterion': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       'entropy', --, --, 'entropy', --, --, --, --, 'gini',
                       'gini', --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False,  True,
                        True, False,  True,  True,  True,  True, False, False,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:extra_trees_preproc_for_classification:max_depth': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       'None', --, --, 'None', --, --, --, --, 'None', 'None',
                       --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False,  True,
                        True, False,  True,  True,  True,  True, False, False,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:extra_trees_preproc_for_classification:max_features': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       0.5823188661500757, --, --, 0.3426173612274873, --, --,
                       --, --, 0.14304289438975937, 0.7413586589865906, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False,  True,
                        True, False,  True,  True,  True,  True, False, False,
                        True],
           fill_value=1e+20),
     'param_feature_preprocessor:extra_trees_preproc_for_classification:max_leaf_nodes': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       'None', --, --, 'None', --, --, --, --, 'None', 'None',
                       --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False,  True,
                        True, False,  True,  True,  True,  True, False, False,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:extra_trees_preproc_for_classification:min_impurity_decrease': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       0.0, --, --, 0.0, --, --, --, --, 0.0, 0.0, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False,  True,
                        True, False,  True,  True,  True,  True, False, False,
                        True],
           fill_value=1e+20),
     'param_feature_preprocessor:extra_trees_preproc_for_classification:min_samples_leaf': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       15.0, --, --, 14.0, --, --, --, --, 12.0, 4.0, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False,  True,
                        True, False,  True,  True,  True,  True, False, False,
                        True],
           fill_value=1e+20),
     'param_feature_preprocessor:extra_trees_preproc_for_classification:min_samples_split': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       5.0, --, --, 10.0, --, --, --, --, 10.0, 20.0, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False,  True,
                        True, False,  True,  True,  True,  True, False, False,
                        True],
           fill_value=1e+20),
     'param_feature_preprocessor:extra_trees_preproc_for_classification:min_weight_fraction_leaf': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       0.0, --, --, 0.0, --, --, --, --, 0.0, 0.0, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False,  True,
                        True, False,  True,  True,  True,  True, False, False,
                        True],
           fill_value=1e+20),
     'param_feature_preprocessor:extra_trees_preproc_for_classification:n_estimators': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       100.0, --, --, 100.0, --, --, --, --, 100.0, 100.0, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False,  True,
                        True, False,  True,  True,  True,  True, False, False,
                        True],
           fill_value=1e+20),
     'param_feature_preprocessor:fast_ica:algorithm': masked_array(data=[--, --, --, --, 'parallel', --, --, 'deflation', --,
                       --, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True, False,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:fast_ica:fun': masked_array(data=[--, --, --, --, 'cube', --, --, 'exp', --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True, False,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:fast_ica:n_components': masked_array(data=[--, --, --, --, --, --, --, 1631.0, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_feature_preprocessor:fast_ica:whiten': masked_array(data=[--, --, --, --, 'False', --, --, 'True', --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True, False,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:feature_agglomeration:affinity': masked_array(data=[--, --, --, --, --, 'euclidean', --, --, --, --, --,
                       'euclidean', --, --, --, --, --, --, --, --, --, --,
                       --, --, 'manhattan'],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                       False],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:feature_agglomeration:linkage': masked_array(data=[--, --, --, --, --, 'complete', --, --, --, --, --,
                       'ward', --, --, --, --, --, --, --, --, --, --, --, --,
                       'average'],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                       False],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:feature_agglomeration:n_clusters': masked_array(data=[--, --, --, --, --, 247.0, --, --, --, --, --, 182.0,
                       --, --, --, --, --, --, --, --, --, --, --, --, 131.0],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                       False],
           fill_value=1e+20),
     'param_feature_preprocessor:feature_agglomeration:pooling_func': masked_array(data=[--, --, --, --, --, 'max', --, --, --, --, --, 'mean',
                       --, --, --, --, --, --, --, --, --, --, --, --, 'mean'],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                       False],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:kernel_pca:coef0': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:kernel_pca:degree': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:kernel_pca:gamma': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:kernel_pca:kernel': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:kernel_pca:n_components': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:kitchen_sinks:gamma': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:kitchen_sinks:n_components': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:liblinear_svc_preprocessor:C': masked_array(data=[--, --, 406.8828992233326, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_feature_preprocessor:liblinear_svc_preprocessor:dual': masked_array(data=[--, --, 'False', --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:liblinear_svc_preprocessor:fit_intercept': masked_array(data=[--, --, 'True', --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:liblinear_svc_preprocessor:intercept_scaling': masked_array(data=[--, --, 1.0, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_feature_preprocessor:liblinear_svc_preprocessor:loss': masked_array(data=[--, --, 'squared_hinge', --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:liblinear_svc_preprocessor:multi_class': masked_array(data=[--, --, 'ovr', --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:liblinear_svc_preprocessor:penalty': masked_array(data=[--, --, 'l1', --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:liblinear_svc_preprocessor:tol': masked_array(data=[--, --, 7.92862192773501e-05, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_feature_preprocessor:nystroem_sampler:coef0': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:nystroem_sampler:degree': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:nystroem_sampler:gamma': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:nystroem_sampler:kernel': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:nystroem_sampler:n_components': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:pca:keep_variance': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:pca:whiten': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:polynomial:degree': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, 2.0, --, 2.0, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                       False,  True, False,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_feature_preprocessor:polynomial:include_bias': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, 'True', --, 'True', --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                       False,  True, False,  True,  True,  True,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:polynomial:interaction_only': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, 'True', --, 'True', --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                       False,  True, False,  True,  True,  True,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:random_trees_embedding:bootstrap': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:random_trees_embedding:max_depth': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:random_trees_embedding:max_leaf_nodes': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:random_trees_embedding:min_samples_leaf': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:random_trees_embedding:min_samples_split': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:random_trees_embedding:min_weight_fraction_leaf': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:random_trees_embedding:n_estimators': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:select_percentile_classification:percentile': masked_array(data=[--, --, --, 93.39844669585806, --, --, --, --,
                       56.29604107917355, 75.75107575487506, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True, False,  True,  True,  True,  True,
                       False, False,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value=1e+20),
     'param_feature_preprocessor:select_percentile_classification:score_func': masked_array(data=[--, --, --, 'f_classif', --, --, --, --, 'chi2',
                       'f_classif', --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --],
                 mask=[ True,  True,  True, False,  True,  True,  True,  True,
                       False, False,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:select_rates_classification:alpha': masked_array(data=[--, 0.32118127649740214, --, --, --, --,
                       0.46621681976184837, --, --, --, 0.14149638953486213,
                       --, 0.011277906829173396, --, --, 0.3801972898691173,
                       --, --, --, --, --, 0.058944567903116155, --, --, --],
                 mask=[ True, False,  True,  True,  True,  True, False,  True,
                        True,  True, False,  True, False,  True,  True, False,
                        True,  True,  True,  True,  True, False,  True,  True,
                        True],
           fill_value=1e+20),
     'param_feature_preprocessor:select_rates_classification:mode': masked_array(data=[--, 'fwe', --, --, --, --, 'fpr', --, --, --, 'fwe',
                       --, 'fdr', --, --, --, --, --, --, --, --, 'fpr', --,
                       --, --],
                 mask=[ True, False,  True,  True,  True,  True, False,  True,
                        True,  True, False,  True, False,  True,  True,  True,
                        True,  True,  True,  True,  True, False,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:select_rates_classification:score_func': masked_array(data=[--, 'chi2', --, --, --, --, 'chi2', --, --, --, 'chi2',
                       --, 'f_classif', --, --, 'mutual_info_classif', --, --,
                       --, --, --, 'f_classif', --, --, --],
                 mask=[ True, False,  True,  True,  True,  True, False,  True,
                        True,  True, False,  True, False,  True,  True, False,
                        True,  True,  True,  True,  True, False,  True,  True,
                        True],
           fill_value='N/A',
                dtype='<U32'),
     'params': [{'balancing:strategy': 'none',
                 'classifier:__choice__': 'random_forest',
                 'classifier:random_forest:bootstrap': 'True',
                 'classifier:random_forest:criterion': 'gini',
                 'classifier:random_forest:max_depth': 'None',
                 'classifier:random_forest:max_features': 0.5,
                 'classifier:random_forest:max_leaf_nodes': 'None',
                 'classifier:random_forest:min_impurity_decrease': 0.0,
                 'classifier:random_forest:min_samples_leaf': 1,
                 'classifier:random_forest:min_samples_split': 2,
                 'classifier:random_forest:min_weight_fraction_leaf': 0.0,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.01,
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'mean',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'standardize',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 0,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'no_preprocessing'},
                {'balancing:strategy': 'none',
                 'classifier:__choice__': 'extra_trees',
                 'classifier:extra_trees:bootstrap': 'True',
                 'classifier:extra_trees:criterion': 'entropy',
                 'classifier:extra_trees:max_depth': 'None',
                 'classifier:extra_trees:max_features': 0.5,
                 'classifier:extra_trees:max_leaf_nodes': 'None',
                 'classifier:extra_trees:min_impurity_decrease': 0.0,
                 'classifier:extra_trees:min_samples_leaf': 1,
                 'classifier:extra_trees:min_samples_split': 2,
                 'classifier:extra_trees:min_weight_fraction_leaf': 0.0,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.1040851795596776,
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'most_frequent',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'none',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'select_rates_classification',
                 'feature_preprocessor:select_rates_classification:alpha': 0.32118127649740214,
                 'feature_preprocessor:select_rates_classification:mode': 'fwe',
                 'feature_preprocessor:select_rates_classification:score_func': 'chi2'},
                {'balancing:strategy': 'weighting',
                 'classifier:__choice__': 'extra_trees',
                 'classifier:extra_trees:bootstrap': 'False',
                 'classifier:extra_trees:criterion': 'entropy',
                 'classifier:extra_trees:max_depth': 'None',
                 'classifier:extra_trees:max_features': 0.7655092431692035,
                 'classifier:extra_trees:max_leaf_nodes': 'None',
                 'classifier:extra_trees:min_impurity_decrease': 0.0,
                 'classifier:extra_trees:min_samples_leaf': 19,
                 'classifier:extra_trees:min_samples_split': 5,
                 'classifier:extra_trees:min_weight_fraction_leaf': 0.0,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'no_coalescense',
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'most_frequent',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'normalize',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'liblinear_svc_preprocessor',
                 'feature_preprocessor:liblinear_svc_preprocessor:C': 406.8828992233326,
                 'feature_preprocessor:liblinear_svc_preprocessor:dual': 'False',
                 'feature_preprocessor:liblinear_svc_preprocessor:fit_intercept': 'True',
                 'feature_preprocessor:liblinear_svc_preprocessor:intercept_scaling': 1,
                 'feature_preprocessor:liblinear_svc_preprocessor:loss': 'squared_hinge',
                 'feature_preprocessor:liblinear_svc_preprocessor:multi_class': 'ovr',
                 'feature_preprocessor:liblinear_svc_preprocessor:penalty': 'l1',
                 'feature_preprocessor:liblinear_svc_preprocessor:tol': 7.92862192773501e-05},
                {'balancing:strategy': 'weighting',
                 'classifier:__choice__': 'gradient_boosting',
                 'classifier:gradient_boosting:early_stop': 'train',
                 'classifier:gradient_boosting:l2_regularization': 3.387912939529945e-10,
                 'classifier:gradient_boosting:learning_rate': 0.30755227194768237,
                 'classifier:gradient_boosting:loss': 'auto',
                 'classifier:gradient_boosting:max_bins': 255,
                 'classifier:gradient_boosting:max_depth': 'None',
                 'classifier:gradient_boosting:max_leaf_nodes': 60,
                 'classifier:gradient_boosting:min_samples_leaf': 39,
                 'classifier:gradient_boosting:n_iter_no_change': 18,
                 'classifier:gradient_boosting:scoring': 'loss',
                 'classifier:gradient_boosting:tol': 1e-07,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.010000000000000004,
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'most_frequent',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'none',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'select_percentile_classification',
                 'feature_preprocessor:select_percentile_classification:percentile': 93.39844669585806,
                 'feature_preprocessor:select_percentile_classification:score_func': 'f_classif'},
                {'balancing:strategy': 'weighting',
                 'classifier:__choice__': 'random_forest',
                 'classifier:random_forest:bootstrap': 'True',
                 'classifier:random_forest:criterion': 'gini',
                 'classifier:random_forest:max_depth': 'None',
                 'classifier:random_forest:max_features': 0.48532133444855097,
                 'classifier:random_forest:max_leaf_nodes': 'None',
                 'classifier:random_forest:min_impurity_decrease': 0.0,
                 'classifier:random_forest:min_samples_leaf': 1,
                 'classifier:random_forest:min_samples_split': 2,
                 'classifier:random_forest:min_weight_fraction_leaf': 0.0,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.010000000000000004,
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'mean',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'minmax',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'fast_ica',
                 'feature_preprocessor:fast_ica:algorithm': 'parallel',
                 'feature_preprocessor:fast_ica:fun': 'cube',
                 'feature_preprocessor:fast_ica:whiten': 'False'},
                {'balancing:strategy': 'weighting',
                 'classifier:__choice__': 'mlp',
                 'classifier:mlp:activation': 'tanh',
                 'classifier:mlp:alpha': 0.00021148999718383549,
                 'classifier:mlp:batch_size': 'auto',
                 'classifier:mlp:beta_1': 0.9,
                 'classifier:mlp:beta_2': 0.999,
                 'classifier:mlp:early_stopping': 'train',
                 'classifier:mlp:epsilon': 1e-08,
                 'classifier:mlp:hidden_layer_depth': 3,
                 'classifier:mlp:learning_rate_init': 0.0007452270241186694,
                 'classifier:mlp:n_iter_no_change': 32,
                 'classifier:mlp:num_nodes_per_layer': 113,
                 'classifier:mlp:shuffle': 'True',
                 'classifier:mlp:solver': 'adam',
                 'classifier:mlp:tol': 0.0001,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'no_coalescense',
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'most_frequent',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'standardize',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'feature_agglomeration',
                 'feature_preprocessor:feature_agglomeration:affinity': 'euclidean',
                 'feature_preprocessor:feature_agglomeration:linkage': 'complete',
                 'feature_preprocessor:feature_agglomeration:n_clusters': 247,
                 'feature_preprocessor:feature_agglomeration:pooling_func': 'max'},
                {'balancing:strategy': 'none',
                 'classifier:__choice__': 'random_forest',
                 'classifier:random_forest:bootstrap': 'True',
                 'classifier:random_forest:criterion': 'entropy',
                 'classifier:random_forest:max_depth': 'None',
                 'classifier:random_forest:max_features': 0.4784709727277252,
                 'classifier:random_forest:max_leaf_nodes': 'None',
                 'classifier:random_forest:min_impurity_decrease': 0.0,
                 'classifier:random_forest:min_samples_leaf': 1,
                 'classifier:random_forest:min_samples_split': 14,
                 'classifier:random_forest:min_weight_fraction_leaf': 0.0,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'no_coalescense',
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'most_frequent',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'none',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'select_rates_classification',
                 'feature_preprocessor:select_rates_classification:alpha': 0.46621681976184837,
                 'feature_preprocessor:select_rates_classification:mode': 'fpr',
                 'feature_preprocessor:select_rates_classification:score_func': 'chi2'},
                {'balancing:strategy': 'weighting',
                 'classifier:__choice__': 'passive_aggressive',
                 'classifier:passive_aggressive:C': 0.008807665845919431,
                 'classifier:passive_aggressive:average': 'False',
                 'classifier:passive_aggressive:fit_intercept': 'True',
                 'classifier:passive_aggressive:loss': 'hinge',
                 'classifier:passive_aggressive:tol': 0.001174447028725537,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.42677247105834165,
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'most_frequent',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'robust_scaler',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_max': 0.7278293151795671,
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_min': 0.16271852122755062,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'fast_ica',
                 'feature_preprocessor:fast_ica:algorithm': 'deflation',
                 'feature_preprocessor:fast_ica:fun': 'exp',
                 'feature_preprocessor:fast_ica:n_components': 1631,
                 'feature_preprocessor:fast_ica:whiten': 'True'},
                {'balancing:strategy': 'weighting',
                 'classifier:__choice__': 'random_forest',
                 'classifier:random_forest:bootstrap': 'False',
                 'classifier:random_forest:criterion': 'entropy',
                 'classifier:random_forest:max_depth': 'None',
                 'classifier:random_forest:max_features': 0.8390317715938469,
                 'classifier:random_forest:max_leaf_nodes': 'None',
                 'classifier:random_forest:min_impurity_decrease': 0.0,
                 'classifier:random_forest:min_samples_leaf': 14,
                 'classifier:random_forest:min_samples_split': 6,
                 'classifier:random_forest:min_weight_fraction_leaf': 0.0,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.15465886171097135,
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'mean',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'robust_scaler',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_max': 0.7083522758919695,
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_min': 0.26017575741727234,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'select_percentile_classification',
                 'feature_preprocessor:select_percentile_classification:percentile': 56.29604107917355,
                 'feature_preprocessor:select_percentile_classification:score_func': 'chi2'},
                {'balancing:strategy': 'weighting',
                 'classifier:__choice__': 'libsvm_svc',
                 'classifier:libsvm_svc:C': 2176.2897327948685,
                 'classifier:libsvm_svc:coef0': -0.018575725453357728,
                 'classifier:libsvm_svc:degree': 2,
                 'classifier:libsvm_svc:gamma': 0.006276539842771683,
                 'classifier:libsvm_svc:kernel': 'poly',
                 'classifier:libsvm_svc:max_iter': -1,
                 'classifier:libsvm_svc:shrinking': 'False',
                 'classifier:libsvm_svc:tol': 7.288971711473298e-05,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.010000000000000004,
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'median',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'robust_scaler',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_max': 0.75,
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_min': 0.2058549350571071,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'select_percentile_classification',
                 'feature_preprocessor:select_percentile_classification:percentile': 75.75107575487506,
                 'feature_preprocessor:select_percentile_classification:score_func': 'f_classif'},
                {'balancing:strategy': 'weighting',
                 'classifier:__choice__': 'gradient_boosting',
                 'classifier:gradient_boosting:early_stop': 'train',
                 'classifier:gradient_boosting:l2_regularization': 0.20982857192812085,
                 'classifier:gradient_boosting:learning_rate': 0.012770531206809599,
                 'classifier:gradient_boosting:loss': 'auto',
                 'classifier:gradient_boosting:max_bins': 255,
                 'classifier:gradient_boosting:max_depth': 'None',
                 'classifier:gradient_boosting:max_leaf_nodes': 32,
                 'classifier:gradient_boosting:min_samples_leaf': 69,
                 'classifier:gradient_boosting:n_iter_no_change': 19,
                 'classifier:gradient_boosting:scoring': 'loss',
                 'classifier:gradient_boosting:tol': 1e-07,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.0005589708287942353,
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'mean',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'robust_scaler',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_max': 0.9803466242807123,
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_min': 0.1005590641662353,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'select_rates_classification',
                 'feature_preprocessor:select_rates_classification:alpha': 0.14149638953486213,
                 'feature_preprocessor:select_rates_classification:mode': 'fwe',
                 'feature_preprocessor:select_rates_classification:score_func': 'chi2'},
                {'balancing:strategy': 'none',
                 'classifier:__choice__': 'mlp',
                 'classifier:mlp:activation': 'tanh',
                 'classifier:mlp:alpha': 0.0001363185819149026,
                 'classifier:mlp:batch_size': 'auto',
                 'classifier:mlp:beta_1': 0.9,
                 'classifier:mlp:beta_2': 0.999,
                 'classifier:mlp:early_stopping': 'valid',
                 'classifier:mlp:epsilon': 1e-08,
                 'classifier:mlp:hidden_layer_depth': 3,
                 'classifier:mlp:learning_rate_init': 0.00018009776276177523,
                 'classifier:mlp:n_iter_no_change': 32,
                 'classifier:mlp:num_nodes_per_layer': 115,
                 'classifier:mlp:shuffle': 'True',
                 'classifier:mlp:solver': 'adam',
                 'classifier:mlp:tol': 0.0001,
                 'classifier:mlp:validation_fraction': 0.1,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'no_coalescense',
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'median',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'standardize',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'feature_agglomeration',
                 'feature_preprocessor:feature_agglomeration:affinity': 'euclidean',
                 'feature_preprocessor:feature_agglomeration:linkage': 'ward',
                 'feature_preprocessor:feature_agglomeration:n_clusters': 182,
                 'feature_preprocessor:feature_agglomeration:pooling_func': 'mean'},
                {'balancing:strategy': 'weighting',
                 'classifier:__choice__': 'gradient_boosting',
                 'classifier:gradient_boosting:early_stop': 'off',
                 'classifier:gradient_boosting:l2_regularization': 5.195231690836764e-09,
                 'classifier:gradient_boosting:learning_rate': 0.06101786517649655,
                 'classifier:gradient_boosting:loss': 'auto',
                 'classifier:gradient_boosting:max_bins': 255,
                 'classifier:gradient_boosting:max_depth': 'None',
                 'classifier:gradient_boosting:max_leaf_nodes': 10,
                 'classifier:gradient_boosting:min_samples_leaf': 22,
                 'classifier:gradient_boosting:scoring': 'loss',
                 'classifier:gradient_boosting:tol': 1e-07,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'no_coalescense',
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'median',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'robust_scaler',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_max': 0.7633589611863135,
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_min': 0.29630657165502694,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'select_rates_classification',
                 'feature_preprocessor:select_rates_classification:alpha': 0.011277906829173396,
                 'feature_preprocessor:select_rates_classification:mode': 'fdr',
                 'feature_preprocessor:select_rates_classification:score_func': 'f_classif'},
                {'balancing:strategy': 'none',
                 'classifier:__choice__': 'sgd',
                 'classifier:sgd:alpha': 2.8077187575610757e-05,
                 'classifier:sgd:average': 'True',
                 'classifier:sgd:fit_intercept': 'True',
                 'classifier:sgd:l1_ratio': 0.275125886570793,
                 'classifier:sgd:learning_rate': 'optimal',
                 'classifier:sgd:loss': 'log',
                 'classifier:sgd:penalty': 'elasticnet',
                 'classifier:sgd:tol': 1.3351064406792789e-05,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'no_coalescense',
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'most_frequent',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'standardize',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'no_preprocessing'},
                {'balancing:strategy': 'none',
                 'classifier:__choice__': 'extra_trees',
                 'classifier:extra_trees:bootstrap': 'True',
                 'classifier:extra_trees:criterion': 'entropy',
                 'classifier:extra_trees:max_depth': 'None',
                 'classifier:extra_trees:max_features': 0.15687109796165688,
                 'classifier:extra_trees:max_leaf_nodes': 'None',
                 'classifier:extra_trees:min_impurity_decrease': 0.0,
                 'classifier:extra_trees:min_samples_leaf': 3,
                 'classifier:extra_trees:min_samples_split': 13,
                 'classifier:extra_trees:min_weight_fraction_leaf': 0.0,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'no_coalescense',
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'median',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'quantile_transformer',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:n_quantiles': 1643,
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:output_distribution': 'uniform',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'extra_trees_preproc_for_classification',
                 'feature_preprocessor:extra_trees_preproc_for_classification:bootstrap': 'False',
                 'feature_preprocessor:extra_trees_preproc_for_classification:criterion': 'entropy',
                 'feature_preprocessor:extra_trees_preproc_for_classification:max_depth': 'None',
                 'feature_preprocessor:extra_trees_preproc_for_classification:max_features': 0.5823188661500757,
                 'feature_preprocessor:extra_trees_preproc_for_classification:max_leaf_nodes': 'None',
                 'feature_preprocessor:extra_trees_preproc_for_classification:min_impurity_decrease': 0.0,
                 'feature_preprocessor:extra_trees_preproc_for_classification:min_samples_leaf': 15,
                 'feature_preprocessor:extra_trees_preproc_for_classification:min_samples_split': 5,
                 'feature_preprocessor:extra_trees_preproc_for_classification:min_weight_fraction_leaf': 0.0,
                 'feature_preprocessor:extra_trees_preproc_for_classification:n_estimators': 100},
                {'balancing:strategy': 'weighting',
                 'classifier:__choice__': 'lda',
                 'classifier:lda:shrinkage': 'auto',
                 'classifier:lda:tol': 0.06502391592449622,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.025659060146568036,
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'median',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'robust_scaler',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_max': 0.75,
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_min': 0.2479524799615851,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'select_rates_classification',
                 'feature_preprocessor:select_rates_classification:alpha': 0.3801972898691173,
                 'feature_preprocessor:select_rates_classification:score_func': 'mutual_info_classif'},
                {'balancing:strategy': 'weighting',
                 'classifier:__choice__': 'extra_trees',
                 'classifier:extra_trees:bootstrap': 'False',
                 'classifier:extra_trees:criterion': 'entropy',
                 'classifier:extra_trees:max_depth': 'None',
                 'classifier:extra_trees:max_features': 0.993803313878608,
                 'classifier:extra_trees:max_leaf_nodes': 'None',
                 'classifier:extra_trees:min_impurity_decrease': 0.0,
                 'classifier:extra_trees:min_samples_leaf': 2,
                 'classifier:extra_trees:min_samples_split': 20,
                 'classifier:extra_trees:min_weight_fraction_leaf': 0.0,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.41826215858914706,
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'median',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'robust_scaler',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_max': 0.7305615609807856,
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_min': 0.25595970768123566,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'polynomial',
                 'feature_preprocessor:polynomial:degree': 2,
                 'feature_preprocessor:polynomial:include_bias': 'True',
                 'feature_preprocessor:polynomial:interaction_only': 'True'},
                {'balancing:strategy': 'none',
                 'classifier:__choice__': 'mlp',
                 'classifier:mlp:activation': 'relu',
                 'classifier:mlp:alpha': 4.073424522787473e-06,
                 'classifier:mlp:batch_size': 'auto',
                 'classifier:mlp:beta_1': 0.9,
                 'classifier:mlp:beta_2': 0.999,
                 'classifier:mlp:early_stopping': 'valid',
                 'classifier:mlp:epsilon': 1e-08,
                 'classifier:mlp:hidden_layer_depth': 3,
                 'classifier:mlp:learning_rate_init': 0.0059180455768467425,
                 'classifier:mlp:n_iter_no_change': 32,
                 'classifier:mlp:num_nodes_per_layer': 27,
                 'classifier:mlp:shuffle': 'True',
                 'classifier:mlp:solver': 'adam',
                 'classifier:mlp:tol': 0.0001,
                 'classifier:mlp:validation_fraction': 0.1,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.00029426245080363384,
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'most_frequent',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'standardize',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'extra_trees_preproc_for_classification',
                 'feature_preprocessor:extra_trees_preproc_for_classification:bootstrap': 'False',
                 'feature_preprocessor:extra_trees_preproc_for_classification:criterion': 'entropy',
                 'feature_preprocessor:extra_trees_preproc_for_classification:max_depth': 'None',
                 'feature_preprocessor:extra_trees_preproc_for_classification:max_features': 0.3426173612274873,
                 'feature_preprocessor:extra_trees_preproc_for_classification:max_leaf_nodes': 'None',
                 'feature_preprocessor:extra_trees_preproc_for_classification:min_impurity_decrease': 0.0,
                 'feature_preprocessor:extra_trees_preproc_for_classification:min_samples_leaf': 14,
                 'feature_preprocessor:extra_trees_preproc_for_classification:min_samples_split': 10,
                 'feature_preprocessor:extra_trees_preproc_for_classification:min_weight_fraction_leaf': 0.0,
                 'feature_preprocessor:extra_trees_preproc_for_classification:n_estimators': 100},
                {'balancing:strategy': 'weighting',
                 'classifier:__choice__': 'gradient_boosting',
                 'classifier:gradient_boosting:early_stop': 'train',
                 'classifier:gradient_boosting:l2_regularization': 0.05488841601458162,
                 'classifier:gradient_boosting:learning_rate': 0.0843846716858782,
                 'classifier:gradient_boosting:loss': 'auto',
                 'classifier:gradient_boosting:max_bins': 255,
                 'classifier:gradient_boosting:max_depth': 'None',
                 'classifier:gradient_boosting:max_leaf_nodes': 4,
                 'classifier:gradient_boosting:min_samples_leaf': 3,
                 'classifier:gradient_boosting:n_iter_no_change': 16,
                 'classifier:gradient_boosting:scoring': 'loss',
                 'classifier:gradient_boosting:tol': 1e-07,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'no_coalescense',
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'mean',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'quantile_transformer',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:n_quantiles': 654,
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:output_distribution': 'uniform',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'polynomial',
                 'feature_preprocessor:polynomial:degree': 2,
                 'feature_preprocessor:polynomial:include_bias': 'True',
                 'feature_preprocessor:polynomial:interaction_only': 'True'},
                {'balancing:strategy': 'none',
                 'classifier:__choice__': 'random_forest',
                 'classifier:random_forest:bootstrap': 'True',
                 'classifier:random_forest:criterion': 'entropy',
                 'classifier:random_forest:max_depth': 'None',
                 'classifier:random_forest:max_features': 0.4678465140755959,
                 'classifier:random_forest:max_leaf_nodes': 'None',
                 'classifier:random_forest:min_impurity_decrease': 0.0,
                 'classifier:random_forest:min_samples_leaf': 1,
                 'classifier:random_forest:min_samples_split': 2,
                 'classifier:random_forest:min_weight_fraction_leaf': 0.0,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.033371278314588006,
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'most_frequent',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'quantile_transformer',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:n_quantiles': 1000,
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:output_distribution': 'uniform',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'no_preprocessing'},
                {'balancing:strategy': 'weighting',
                 'classifier:__choice__': 'adaboost',
                 'classifier:adaboost:algorithm': 'SAMME',
                 'classifier:adaboost:learning_rate': 0.2844845910527844,
                 'classifier:adaboost:max_depth': 2,
                 'classifier:adaboost:n_estimators': 370,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.3519795567275179,
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'median',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'standardize',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'no_preprocessing'},
                {'balancing:strategy': 'none',
                 'classifier:__choice__': 'passive_aggressive',
                 'classifier:passive_aggressive:C': 1.0,
                 'classifier:passive_aggressive:average': 'True',
                 'classifier:passive_aggressive:fit_intercept': 'True',
                 'classifier:passive_aggressive:loss': 'hinge',
                 'classifier:passive_aggressive:tol': 0.00010000000000000009,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.010000000000000004,
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'median',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'none',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'select_rates_classification',
                 'feature_preprocessor:select_rates_classification:alpha': 0.058944567903116155,
                 'feature_preprocessor:select_rates_classification:mode': 'fpr',
                 'feature_preprocessor:select_rates_classification:score_func': 'f_classif'},
                {'balancing:strategy': 'weighting',
                 'classifier:__choice__': 'random_forest',
                 'classifier:random_forest:bootstrap': 'False',
                 'classifier:random_forest:criterion': 'entropy',
                 'classifier:random_forest:max_depth': 'None',
                 'classifier:random_forest:max_features': 0.6008565943377931,
                 'classifier:random_forest:max_leaf_nodes': 'None',
                 'classifier:random_forest:min_impurity_decrease': 0.0,
                 'classifier:random_forest:min_samples_leaf': 4,
                 'classifier:random_forest:min_samples_split': 2,
                 'classifier:random_forest:min_weight_fraction_leaf': 0.0,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'no_coalescense',
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'mean',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'robust_scaler',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_max': 0.9807302775111806,
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_min': 0.2839332787950659,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 6,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 3,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 1,
                 'feature_preprocessor:__choice__': 'extra_trees_preproc_for_classification',
                 'feature_preprocessor:extra_trees_preproc_for_classification:bootstrap': 'True',
                 'feature_preprocessor:extra_trees_preproc_for_classification:criterion': 'gini',
                 'feature_preprocessor:extra_trees_preproc_for_classification:max_depth': 'None',
                 'feature_preprocessor:extra_trees_preproc_for_classification:max_features': 0.14304289438975937,
                 'feature_preprocessor:extra_trees_preproc_for_classification:max_leaf_nodes': 'None',
                 'feature_preprocessor:extra_trees_preproc_for_classification:min_impurity_decrease': 0.0,
                 'feature_preprocessor:extra_trees_preproc_for_classification:min_samples_leaf': 12,
                 'feature_preprocessor:extra_trees_preproc_for_classification:min_samples_split': 10,
                 'feature_preprocessor:extra_trees_preproc_for_classification:min_weight_fraction_leaf': 0.0,
                 'feature_preprocessor:extra_trees_preproc_for_classification:n_estimators': 100},
                {'balancing:strategy': 'weighting',
                 'classifier:__choice__': 'extra_trees',
                 'classifier:extra_trees:bootstrap': 'False',
                 'classifier:extra_trees:criterion': 'gini',
                 'classifier:extra_trees:max_depth': 'None',
                 'classifier:extra_trees:max_features': 0.36338266699494315,
                 'classifier:extra_trees:max_leaf_nodes': 'None',
                 'classifier:extra_trees:min_impurity_decrease': 0.0,
                 'classifier:extra_trees:min_samples_leaf': 10,
                 'classifier:extra_trees:min_samples_split': 5,
                 'classifier:extra_trees:min_weight_fraction_leaf': 0.0,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'no_coalescense',
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'median',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'none',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding_distinct',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:min_df_choice': 'min_df_relative',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:min_df_relative': 0.5081124812807862,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:ngram_upper_bound': 2,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 6,
                 'feature_preprocessor:__choice__': 'extra_trees_preproc_for_classification',
                 'feature_preprocessor:extra_trees_preproc_for_classification:bootstrap': 'False',
                 'feature_preprocessor:extra_trees_preproc_for_classification:criterion': 'gini',
                 'feature_preprocessor:extra_trees_preproc_for_classification:max_depth': 'None',
                 'feature_preprocessor:extra_trees_preproc_for_classification:max_features': 0.7413586589865906,
                 'feature_preprocessor:extra_trees_preproc_for_classification:max_leaf_nodes': 'None',
                 'feature_preprocessor:extra_trees_preproc_for_classification:min_impurity_decrease': 0.0,
                 'feature_preprocessor:extra_trees_preproc_for_classification:min_samples_leaf': 4,
                 'feature_preprocessor:extra_trees_preproc_for_classification:min_samples_split': 20,
                 'feature_preprocessor:extra_trees_preproc_for_classification:min_weight_fraction_leaf': 0.0,
                 'feature_preprocessor:extra_trees_preproc_for_classification:n_estimators': 100},
                {'balancing:strategy': 'weighting',
                 'classifier:__choice__': 'mlp',
                 'classifier:mlp:activation': 'tanh',
                 'classifier:mlp:alpha': 0.000105725428203196,
                 'classifier:mlp:batch_size': 'auto',
                 'classifier:mlp:beta_1': 0.9,
                 'classifier:mlp:beta_2': 0.999,
                 'classifier:mlp:early_stopping': 'valid',
                 'classifier:mlp:epsilon': 1e-08,
                 'classifier:mlp:hidden_layer_depth': 3,
                 'classifier:mlp:learning_rate_init': 0.0010000000000000002,
                 'classifier:mlp:n_iter_no_change': 32,
                 'classifier:mlp:num_nodes_per_layer': 32,
                 'classifier:mlp:shuffle': 'True',
                 'classifier:mlp:solver': 'adam',
                 'classifier:mlp:tol': 0.0001,
                 'classifier:mlp:validation_fraction': 0.1,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'no_coalescense',
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'mean',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'robust_scaler',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_max': 0.8650501969026246,
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_min': 0.19685017087313914,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding_distinct',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:min_df_choice': 'min_df_relative',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:min_df_relative': 0.010000000000000004,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 1004,
                 'feature_preprocessor:__choice__': 'feature_agglomeration',
                 'feature_preprocessor:feature_agglomeration:affinity': 'manhattan',
                 'feature_preprocessor:feature_agglomeration:linkage': 'average',
                 'feature_preprocessor:feature_agglomeration:n_clusters': 131,
                 'feature_preprocessor:feature_agglomeration:pooling_func': 'mean'}],
     'rank_test_precision': array([ 3,  6, 21, 10,  8,  2,  4, 19, 13, 22, 16,  9, 14,  7,  5, 22, 18,
           17, 11,  1, 20, 22, 12, 15, 22]),
     'rank_test_recall': array([14, 12,  8,  9, 20, 10, 14, 17,  2, 22,  3, 19,  6, 10, 21, 22, 13,
           18,  7, 14,  4, 22,  5,  1, 22]),
     'status': ['Success',
                'Success',
                'Success',
                'Success',
                'Success',
                'Success',
                'Success',
                'Success',
                'Success',
                'Timeout',
                'Success',
                'Success',
                'Success',
                'Success',
                'Success',
                'Success',
                'Success',
                'Success',
                'Success',
                'Success',
                'Success',
                'Success',
                'Success',
                'Success',
                'Timeout']}




.. GENERATED FROM PYTHON SOURCE LINES 74-76

Visualize the Pareto set
==========================

.. GENERATED FROM PYTHON SOURCE LINES 76-91

.. code-block:: default

    plot_values = []
    pareto_front = automl.get_pareto_set()
    for ensemble in pareto_front:
        predictions = ensemble.predict(X_test)
        precision = sklearn.metrics.precision_score(y_test, predictions)
        recall = sklearn.metrics.recall_score(y_test, predictions)
        plot_values.append((precision, recall))
    fig = plt.figure()
    ax = fig.add_subplot(111)
    for precision, recall in plot_values:
        ax.scatter(precision, recall, c="blue")
    ax.set_xlabel("Precision")
    ax.set_ylabel("Recall")
    ax.set_title("Pareto set")
    plt.show()



.. image-sg:: /examples/40_advanced/images/sphx_glr_example_multi_objective_001.png
   :alt: Pareto set
   :srcset: /examples/40_advanced/images/sphx_glr_example_multi_objective_001.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 2 minutes  9.436 seconds)


.. _sphx_glr_download_examples_40_advanced_example_multi_objective.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example


  .. container:: binder-badge

    .. image:: images/binder_badge_logo.svg
      :target: https://mybinder.org/v2/gh/automl/auto-sklearn/master?urlpath=lab/tree/notebooks/examples/40_advanced/example_multi_objective.ipynb
      :alt: Launch binder
      :width: 150 px


  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: example_multi_objective.py <example_multi_objective.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: example_multi_objective.ipynb <example_multi_objective.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
